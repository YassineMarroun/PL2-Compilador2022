package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;
import java.util.Map.Entry;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;

// Declaración de no terminales

non terminal  							program;
non terminal Axiom						axiom;
non terminal  							epsilon;
non terminal  							defconstantes;
non terminal ValorConstante				valorconstante;
non terminal  							seccionconstantes;
non terminal  							deftipos;
non terminal TypeIF						tipovector;
non terminal ValorRango					valorango;
non terminal  							secciontipos;
non terminal DefVariables 				defvariables;
non terminal TypeIF						tipovariable;
non terminal ListaVariables 			listavariables;
non terminal  							seccionvariables;
non terminal  							defsubprograma;
non terminal							puntoycomaopcional;

non terminal TypeIF 					tiporetornofuncion;
non terminal  							seccionsubprograma;
non terminal DefPrincipal 				defprincipal;
non terminal SelectorValorOReferencia	selectorvalororeferencia;

non terminal Expresion					expresion;
non terminal Expresion					expresionlvl2;
non terminal Expresion					expresionlvl3;
non terminal Expresion					expresionlvl4;
non terminal Expresion					expresionlvl5;

non terminal MiembroVector				miembrovector;
non terminal							procedimiento;
non terminal							funcion;
non terminal							selectorpof;

non terminal ListaVariables          	parametrofuncionoproc;
non terminal LlamadaFuncion				llamadafuncion; 

non terminal ParteIzquierdaAsignacion 	parteizquierdaasignacion;  
non terminal SentenciaDeAsignacion 		sentenciadeasignacion;

non terminal ParametroEscribir			parametroEscribir;
non terminal SentenciaEscribir			sentenciaEscribir;

non terminal Sentencia 					sentencia;
non terminal Sentencia					sentenciaFuncion;
non terminal ListaSentencias			listaSentencias;
non terminal ListaSentencias			listaSentenciasFuncion;
non terminal SentenciaIf 				sentenciaif;
non terminal SentenciaIf 				sentenciaifFuncion;
non terminal RellenoIf					rellenoif;
non terminal RellenoIf					rellenoifFuncion;
non terminal SentenciaFor 				sentenciafor;
non terminal SentenciaFor				sentenciaforFuncion;
non terminal SentenciaDevolver 			sentenciaDevolver;

non terminal Expresion					parametroasignacion;

non terminal SentenciaLlamadaFuncion	sentenciallamadafuncion;


// Declaración de relaciones de precedencia
precedence left		PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA ;
precedence left 	PRODUCTO;
precedence right	NOLOGICO;

// Declaración de reglas de producción

start with program;

program ::= 
{: 
	syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
:}
axiom:ax
{: 
  	// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  	List<QuadrupleIF> intermediateCode = ax.getIntermediateCode ();
  	
	HashMap<String, String> textos = Textos.getTextos();
	syntaxErrorManager.syntaxInfo("TEXTOS: ");
	syntaxErrorManager.syntaxInfo("*****************");
	for(Entry<String, String> e : textos.entrySet()) {
		syntaxErrorManager.syntaxInfo(e.getKey() + ": " + e.getValue());
	}

	syntaxErrorManager.syntaxInfo("CODIGO INTERMEDIO");
	syntaxErrorManager.syntaxInfo("*****************");
	for(QuadrupleIF q : intermediateCode) {
		syntaxErrorManager.syntaxInfo(q.toString());
	}

	finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
	finalCodeFactory.create(intermediateCode);

  	// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  	// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  	// aún no se tendrá implementada la generación de código intermedio ni final.
  	// Para la entrega final deberán descomentarse y usarse.
  		
  	syntaxErrorManager.syntaxInfo ("Parsing process ended.");
:};

axiom ::= defprincipal:defP {:
	AxiomPrincipal axiom = new AxiomPrincipal();
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);

	// Se asignan direcciones de memoria
	MemoriaPrograma memoria = new MemoriaPrograma();
	memoria.asignarMemoria();

	cb.addQuadruple("INICIO", new Value(memoria.direccionInicio));
	cb.addQuadruples(defP.getIntermediateCode());
	cb.addQuadruple("HALT");

	axiom.setIntermediateCode(cb.create());

	RESULT = axiom;
:};

epsilon ::=;

// Definición de constantes
defconstantes ::= IDEN:id ASIGNACION valorconstante:valor DSENTENCIAS defconstantes {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	String nombre = id.getLexema().toUpperCase();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	
	// Comprobación unicidad
	if(simbolosTabla.containsSymbol(nombre)) {
		semanticErrorManager.semanticFatalError("Error semantico: identificador "+ nombre +" duplicado");
	}
	
	if(valor.isEsValorEntero()) {
		// Constante entera
		TypeIF tipo = tiposTabla.getType("ENTERO");
		int valorEntero = valor.getValorEntero();
		SymbolConstantEntero simboloConstante = new SymbolConstantEntero(ambito, nombre, tipo, valorEntero);
		simbolosTabla.addSymbol(simboloConstante);
	} else {
		// Constante lógica
		TypeIF tipo = tiposTabla.getType("LOGICO");
		boolean valorLogico = valor.getValorLogico();
		SymbolConstantLogico simboloConstante = new SymbolConstantLogico(ambito, nombre, tipo, valorLogico);
		simbolosTabla.addSymbol(simboloConstante);
	}
:}
| epsilon; 

valorconstante ::= FALSO {: RESULT = new ValorConstante(false); :}
| CIERTO {: RESULT = new ValorConstante(true); :} 
| NUM:n {: RESULT = new ValorConstante(Integer.parseInt(n.getLexema())); :};

seccionconstantes ::= BCONSTANTES defconstantes
| epsilon;

 // Definición de tipos
deftipos ::= IDEN:id ASIGNACION DECLVECTOR CIZQUIERDO valorango:valorn1 RANGO valorango:valorn2 CDERECHO ASIGNACIONVECTOR tipovector:tipo DSENTENCIAS deftipos {:
	String nombre = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	
	// Comprobación unicidad
	if(tiposTabla.containsType(nombre)) {
		semanticErrorManager.semanticFatalError("Error semantico: identificador del tipo " + nombre + " duplicado");
	}

	// Se recupera valor de rango
	int rango1 = valorn1.getRangoVector();
	int rango2 = valorn2.getRangoVector();

	if(rango2 >= rango1) {
		TypeArray tipoArray = new TypeArray(ambito, nombre, rango1, rango2, tipo);
		tiposTabla.addType(tipoArray);
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: el rango 2 del vector debe ser mayor o igual que el rango 1");
	}
:} 
| epsilon;

tipovector ::= BOOLEANO {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	RESULT = tipo;
:} 
| ENTERO {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	RESULT = tipo;
:};

valorango ::= NUM:n {:
	ValorRango vRango = new ValorRango(Integer.parseInt(n.getLexema()));
	RESULT = vRango;
:}
| IDEN:id {:
	String nombre = id.getLexema().toUpperCase();
	// Se busca el símbolo en la Tabla de Símbolos
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
		
	if(simbolosTabla.containsSymbol(nombre)) {
		SymbolIF s = simbolosTabla.getSymbol(nombre);
		ValorRango vRango = new ValorRango(s);
		RESULT = vRango;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: identificador " + nombre + " no esta declarado");
	}
:}
| miembrovector:miembro {:
	ValorRango vRango = new ValorRango(miembro);
	RESULT = vRango;
:};

secciontipos ::= COMIENZODECLTIPOS deftipos
| epsilon; 

// Definición de variables
tipovariable ::= BOOLEANO {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	RESULT = tipo;
:}
| ENTERO {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	RESULT = tipo;
	
:}
| IDEN:id {:
	String nombreTipo = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();

	if(tiposTabla.containsType(nombreTipo)) {
		TypeIF tipo = tiposTabla.getType(nombreTipo);
		RESULT = tipo;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: el tipo " + nombreTipo + " no esta declarado");
	}
:};

selectorvalororeferencia ::= PARAMETROVALOR IDEN:id {:
	String nombre = id.getLexema().toUpperCase();
	SelectorValorOReferencia selector = new SelectorValorOReferencia(nombre);
	RESULT = selector;
:}
| expresion:exp {:
	SelectorValorOReferencia selector = new SelectorValorOReferencia(exp);
	RESULT = selector;
:};

defvariables ::= listavariables:variables DELIMFUNC tipovariable:tipo puntoycomaopcional defvariables {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	ArrayList<SelectorValorOReferencia> identificadores = variables.getVariables();
	ArrayList<SymbolVariable> parametros = new ArrayList<SymbolVariable>();

	for(SelectorValorOReferencia selector : identificadores) {
		
		String nombre;
		if(selector.isPasoReferencia()) {
			nombre = selector.getIdentificador();
		} else {
			nombre = selector.getExpresion().getIdentificador();
		}

		// Comprobación unicidad
		if(simbolosTabla.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("Error semantico: identificador " + nombre + " duplicado");
		}
		SymbolVariable simbolo = new SymbolVariable(ambito, nombre, tipo, selector.isPasoReferencia());
		simbolosTabla.addSymbol(simbolo);
		parametros.add(simbolo);
	}

	DefVariables defV = new DefVariables(parametros);
	RESULT = defV;
:}
| epsilon {:
	DefVariables defV = new DefVariables();
	RESULT = defV;
:}; 

listavariables ::= selectorvalororeferencia:selector DIDENTIFICADORES listavariables:variables {:
	variables.addSelector(selector);
	RESULT = variables;
:}
| selectorvalororeferencia:selector {:
	ListaVariables variables = new ListaVariables();
	variables.addSelector(selector);
	RESULT = variables;
:}
| epsilon {:
	ListaVariables variables = new ListaVariables();
	RESULT = variables;
:};

seccionvariables ::= DECLVARIABLES defvariables
| epsilon;

puntoycomaopcional ::= DSENTENCIAS
| epsilon;

// Reglas de subprogramas
tiporetornofuncion ::= IDEN:id {:
	// No se permite devolver un vector
	semanticErrorManager.semanticFatalError("La funcion no puede devolver un tipo que no sea primitivo");
:}
| tipovector:tipo {:
	RESULT = tipo;
:};

procedimiento ::= COMIENZOPROCEDIMIENTO IDEN:id {:
	// Al detectar el id del procedimiento se tiene que abrir el ámbito
	String nombre = id.getLexema().toUpperCase();
	scopeManager.openScope(nombre);
	
	// Añadir tipos primitivos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeEntero entero = new TypeEntero(ambito);
	TypeLogico logico = new TypeLogico(ambito);
	TypeTableIF tiposTabla = ambito.getTypeTable();
	tiposTabla.addType(entero);
	tiposTabla.addType(logico);
	
	syntaxErrorManager.syntaxInfo("Ambito procedimiento " + nombre + " abierto");
:} PIZQUIERDO defvariables:parametros PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias FINBLOQUESENTENCIAS DSENTENCIAS {:
	String nombre = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	ScopeIF ambitoPadre = scopeManager.getParentScope();
	TypeTableIF tiposTablaPadre = ambitoPadre.getTypeTable();
	
	TypeProcedure tipo = new TypeProcedure(ambitoPadre, nombre, parametros.getVariables());
	tiposTablaPadre.addType(tipo);
	
	syntaxErrorManager.syntaxInfo("Ambito procedimiento " + nombre + " cerrado");
	scopeManager.closeScope();
:};

funcion ::= DECLAREFUNCION IDEN:id {:
	// Al detectar el id de la función se tiene que abrir el ámbito
	String nombre = id.getLexema().toUpperCase();
	scopeManager.openScope(nombre);
	
	// Añadir tipos primitivos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeEntero entero = new TypeEntero(ambito);
	TypeLogico logico = new TypeLogico(ambito);
	TypeTableIF tiposTabla = ambito.getTypeTable();
	tiposTabla.addType(entero);
	tiposTabla.addType(logico);

	syntaxErrorManager.syntaxInfo("Ambito funcion " + nombre + " abierto");
:} PIZQUIERDO defvariables:parametros PDERECHO DELIMFUNC tiporetornofuncion:retorno DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion:sentencia listaSentenciasFuncion:sentencias FINBLOQUESENTENCIAS DSENTENCIAS {:
	String nombre = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	ScopeIF ambitoPadre = scopeManager.getParentScope();
	TypeTableIF tiposTablaPadre = ambitoPadre.getTypeTable();

	TypeFunction tipo = new TypeFunction(ambitoPadre, nombre, parametros.getVariables(), retorno);
	tiposTablaPadre.addType(tipo);
	System.out.println("Tipo añadido: " + tipo);
	
	// Comprobar que al menos se tiene un DEVOLVER en el cuerpo de la función
	Funcion funcion = new Funcion(sentencias.getSentencias(), sentencia);
	int numeroDevolver = funcion.comprobarDevolver(funcion.getSentencias());
	System.out.println("Numero sentencia devolver: " + numeroDevolver);
	
	if(numeroDevolver == 0) {
		semanticErrorManager.semanticFatalError("Funcion " + nombre + " no tiene sentencia DEVOLVER");
	}

	syntaxErrorManager.syntaxInfo("Ambito funcion " + nombre + " cerrado");
	scopeManager.closeScope();
:};

selectorpof ::= procedimiento
| funcion;

defsubprograma ::= selectorpof defsubprograma
| epsilon;

seccionsubprograma ::= COMIENZOSUBPROGRAMAS defsubprograma
| epsilon;

// Definición de programa principal
defprincipal ::= COMIENZOPROGRAMA IDEN:id {:
	// Abrir ámbito principal
	String nombre = id.getLexema().toUpperCase();
	scopeManager.openScope(nombre);
	syntaxErrorManager.syntaxInfo("Ambito principal " + nombre + " abierto");
	// Añadir tipos primitivos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeEntero entero = new TypeEntero(ambito);
	TypeLogico logico = new TypeLogico(ambito);
	TypeTableIF tiposTabla = ambito.getTypeTable();
	tiposTabla.addType(entero);
	tiposTabla.addType(logico);
:} DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias:sentencias FINBLOQUESENTENCIAS FINPROGRAMA {:
	DefPrincipal defP = new DefPrincipal();

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	cb.addQuadruples(sentencias.getIntermediateCode());
	defP.setIntermediateCode(cb.create());

	RESULT = defP;
:};

expresion ::= expresion:exp1 MENORQUE expresion:exp2 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semantico: los dos operandos en < deben ser de tipo entero");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);

	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("LS", temp, exp1.getTemporal(), exp2.getTemporal());
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;
:}
| expresion:exp1 IGUALDAD expresion:exp2 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO o los dos de tipo LOGICO
	if((!((tipoExp1 instanceof TypeEntero) && (tipoExp2 instanceof TypeEntero))) && (!((tipoExp1 instanceof TypeLogico) && (tipoExp2 instanceof TypeLogico)))) {
		semanticErrorManager.semanticFatalError("Error semantico:los dos operandos en == deben ser de tipo entero, o bien de tipo logico");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("EQ", temp, exp1.getTemporal(), exp2.getTemporal());
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);
	
	RESULT = exp;

:}
| IDEN:id {:
	String identificador = id.getLexema().toUpperCase();
	Expresion exp = new Expresion(identificador);

	// CÓDIGO INTERMEDIO
	if(scopeManager.containsSymbol(identificador)) {
		SymbolIF simboloID = scopeManager.searchSymbol(identificador);
		ScopeIF ambito = scopeManager.getCurrentScope();
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
		TemporalFactory tF = new TemporalFactory(ambito);
		TemporalIF temp = tF.create();

		// Es una variable
		if(simboloID instanceof SymbolVariable) {
			TemporalIF tempMVP = tF.create();
			cb.addQuadruple("MVA", temp, new Variable((SymbolVariable)simboloID));
			cb.addQuadruple("MVP", tempMVP, temp);
			exp.setTemporal(tempMVP);
		}
		// Es una constante de tipo ENTERO
		else if (simboloID instanceof SymbolConstantEntero) {
			int num = ((SymbolConstantEntero)simboloID).getValorEntero();
			cb.addQuadruple("MV", temp, new Value(num));
			exp.setTemporal(temp);
		}
		// Es una contante de tipo LÓGICO
		else {
			boolean logico = ((SymbolConstantLogico)simboloID).getValorLogico();
			if(logico) {
				cb.addQuadruple("MV", temp, new Value(1));
				exp.setTemporal(temp);
			} else {
				cb.addQuadruple("MV", temp, new Value(0));
				exp.setTemporal(temp);
			}
		}
		exp.setIntermediateCode(cb.create());
	}
	RESULT = exp;
:}
| llamadafuncion:llamada {:
	// Tiene que ser una función
	TypeProcedure tipo = llamada.getTipoSubprograma();
	if(tipo instanceof TypeFunction) {
		TypeIF tipoRetorno = ((TypeFunction)tipo).getTipoRetorno();
		Expresion exp = new Expresion(tipoRetorno);
		RESULT = exp;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: expresion de llamada a funcion debe ser una funcion");
	}
:}
| CIERTO {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruple("MV", temp, new Value(1));
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);
	
	RESULT = exp;
:}
| FALSO {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);

	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruple("MV", temp, new Value(0));
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;
:}
| miembrovector:mVector {:
	Expresion exp = new Expresion(mVector.getTipoMiembroVector());
	RESULT = exp;
:}
| NUM:n {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	int num = Integer.parseInt(n.getLexema());
	Expresion exp = new Expresion(tipo);

	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruple("MV", temp, new Value(num));
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;
:}
| expresionlvl2:exp {:
	RESULT = exp;
:};

expresionlvl2 ::= expresion:exp1 SUMA expresion:exp2 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semantico: los dos operandos en + deben ser de tipo entero");
	}

	// Se genera una expresión de tipo ENTERO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	Expresion exp = new Expresion(tipo);

	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	TemporalIF tempEx1 = exp1.getTemporal();
	TemporalIF tempEx2 = exp2.getTemporal();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("ADD", temp, tempEx1, tempEx2);
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;
:}
| expresionlvl3:exp {:
	RESULT = exp;
:};

expresionlvl3 ::= expresion:exp1 YLOGICA expresion:exp2 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo LOGICO
	if(!(tipoExp1 instanceof TypeLogico) || !(tipoExp2 instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semantico: los dos operandos en Y deben ser de tipo logico");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("AND", temp, exp1.getTemporal(), exp2.getTemporal());
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);
	
	RESULT = exp;
:}
| expresion:exp1 PRODUCTO expresion:exp2 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semantico: los dos operandos en * deben ser de tipo entero");
	}

	// Se genera una expresión de tipo ENTERO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	TemporalIF tempEx1 = exp1.getTemporal();
	TemporalIF tempEx2 = exp2.getTemporal();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("MUL", temp, tempEx1, tempEx2);
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);
	
	RESULT = exp;
:}
| expresionlvl4:exp {:
	RESULT = exp;
:};

expresionlvl4 ::= NOLOGICO expresion:exp1 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();

	// Tiene que ser de tipo LOGICO
	if(!(tipoExp1 instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semantico: el operando en NO debe ser de tipo logico");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruple("NOT", temp, exp1.getTemporal());
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;
:}
| expresionlvl5:exp {:
	RESULT = exp;
:};

expresionlvl5 ::= PIZQUIERDO expresion:exp PDERECHO {:
	RESULT = exp;
:}
| CIZQUIERDO expresion:exp CDERECHO {:
	RESULT = exp;
:};


// Acceso a vectores
miembrovector ::= IDEN:id CIZQUIERDO valorango:valorRango CDERECHO {:
	String identificador = id.getLexema().toUpperCase();
	MiembroVector m = new MiembroVector(identificador, valorRango);
	m.comprobarMiembroVector();
	RESULT = m;
:};
 
// Sentencias de asignación
parteizquierdaasignacion ::= IDEN:id {:
	String identificador = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	if(!simbolosTabla.containsSymbol(identificador)) {
		semanticErrorManager.semanticFatalError("Error semantico: identificador " + identificador + " no esta declarado");
	}
	SymbolIF simbolo = simbolosTabla.getSymbol(identificador);
	ParteIzquierdaAsignacion parteIzquierda = new ParteIzquierdaAsignacion(simbolo.getType());
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruple("MVA", temp, new Variable((SymbolVariable)simbolo));
	parteIzquierda.setIntermediateCode(cb.create());
	parteIzquierda.setTemporal(temp);
	
	RESULT = parteIzquierda;
:}
| miembrovector:mVector {:
	ParteIzquierdaAsignacion parteIzquierda = new ParteIzquierdaAsignacion(mVector.getTipoMiembroVector());
	RESULT = parteIzquierda;
:};

sentenciadeasignacion ::= parteizquierdaasignacion:parteIzquierda ASIGNACION parametroasignacion:exp DSENTENCIAS {:
	TypeIF tipoIzquierda = parteIzquierda.getTipoIzquierdo();
	TypeIF tipoParametro = exp.getTipoExpresion();

	// Los dos tienen que ser iguales
	if((tipoIzquierda instanceof TypeEntero && tipoParametro instanceof TypeEntero) || (tipoIzquierda instanceof TypeLogico && tipoParametro instanceof TypeLogico)) {
		SentenciaDeAsignacion sentencia = new SentenciaDeAsignacion();
		
		// CÓDIGO INTERMEDIO
		ScopeIF ambito = scopeManager.getCurrentScope();
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
		TemporalFactory tF = new TemporalFactory(ambito);
		TemporalIF temp = tF.create();
		cb.addQuadruples(exp.getIntermediateCode());
		cb.addQuadruples(parteIzquierda.getIntermediateCode());
		cb.addQuadruple("STP", parteIzquierda.getTemporal(), exp.getTemporal());
		sentencia.setIntermediateCode(cb.create());

		RESULT = sentencia;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: tipos incompatibles en la sentencia de asignacion");
	}
:};

parametroasignacion ::= expresion:exp {:
	RESULT = exp;
:};

// Llamada a función
parametrofuncionoproc ::= listavariables:lista {:
	RESULT = lista;
:};

llamadafuncion ::= IDEN:id PIZQUIERDO parametrofuncionoproc:parametros PDERECHO {:
	String nombre = id.getLexema().toUpperCase();
	// Se busca el tipo nombre en la Tabla de Tipos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	System.out.println(tiposTabla);
	TypeIF tipo = tiposTabla.getType(nombre);

	if(tipo != null) {
		// El tipo tiene que ser una función
		if(tipo instanceof TypeProcedure) {
			LlamadaFuncion llamada = new LlamadaFuncion((TypeProcedure)tipo, parametros.getVariables());
			llamada.comprobarLlamada();
			RESULT = llamada;
		} else {
			semanticErrorManager.semanticFatalError("Error semantico: " + nombre + " no es un subprograma");
		}
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: no existe la funcion " + nombre);
	}
:};

sentenciallamadafuncion ::= llamadafuncion DSENTENCIAS {:
	SentenciaLlamadaFuncion s = new SentenciaLlamadaFuncion();
	RESULT = s;
:};

// Sentencias
sentencia ::= sentenciadeasignacion:s {: RESULT = s; :}
| sentenciaif:s {: RESULT = s; :}
| sentenciafor:s {: RESULT = s; :}
| sentenciaEscribir:s {: RESULT = s; :}
| sentenciallamadafuncion:s {: RESULT = s; :};

sentenciaFuncion ::= sentenciadeasignacion:s {: RESULT = s; :}
| sentenciaifFuncion:s {: RESULT = s; :}
| sentenciaforFuncion:s {: RESULT = s; :}
| sentenciaEscribir:s {: RESULT = s; :}
| sentenciallamadafuncion:s {: RESULT = s; :}
| sentenciaDevolver:s {: RESULT = s; :};

listaSentencias ::= sentencia:s listaSentencias:lista {:
	lista.addSentencia(s);
	
	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	cb.addQuadruples(s.getIntermediateCode());
	cb.addQuadruples(lista.getIntermediateCode());
	lista.setIntermediateCode(cb.create());

	RESULT = lista;
:}
| epsilon {:
	ListaSentencias lista = new ListaSentencias();
	RESULT = lista;
:};

listaSentenciasFuncion ::= sentenciaFuncion:s listaSentenciasFuncion:lista {:
	lista.addSentencia(s);

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	cb.addQuadruples(s.getIntermediateCode());
	cb.addQuadruples(lista.getIntermediateCode());
	lista.setIntermediateCode(cb.create());

	RESULT = lista;
:}
| epsilon {:
	ListaSentencias lista = new ListaSentencias();
	RESULT = lista;
:};

// if
sentenciaif ::= COMIENZOSI expresion:exp STARTIF DELIMFUNC listaSentencias:sentenciasIF rellenoif:relleno FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS {:
	TypeIF tipoExp = exp.getTipoExpresion();

	// Tiene que ser de tipo LOGICO
	if(!(tipoExp instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semántico: la expresión en sentencia IF debe ser de tipo lógico");
	}
	
	SentenciaIf s = new SentenciaIf(sentenciasIF.getSentencias(), relleno.getSentencias());
	RESULT = s;
:};

sentenciaifFuncion ::= COMIENZOSI expresion:exp STARTIF DELIMFUNC listaSentenciasFuncion:sentenciasIF rellenoifFuncion:relleno FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS {:
	TypeIF tipoExp = exp.getTipoExpresion();

	// Tiene que ser de tipo LOGICO
	if(!(tipoExp instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semántico: la expresión en sentencia IF debe ser de tipo lógico");
	}

	SentenciaIf s = new SentenciaIf(sentenciasIF.getSentencias(), relleno.getSentencias());
	RESULT = s;
:};

rellenoifFuncion ::= ALTERNATIVASI DELIMFUNC listaSentenciasFuncion:sentencias {:
	RellenoIf r = new RellenoIf(sentencias.getSentencias());
	RESULT = r;
:}
| epsilon {:
	RellenoIf r = new RellenoIf();
	RESULT = r;
:};

rellenoif ::= ALTERNATIVASI DELIMFUNC listaSentencias:sentencias {:
	RellenoIf r = new RellenoIf(sentencias.getSentencias());
	RESULT = r;
:}
| epsilon {:
	RellenoIf r = new RellenoIf();
	RESULT = r;
:};

// for 
sentenciafor ::= COMIENZOBUCLEPARA IDEN:id RANGOBUCLEPARA expresion:exp1 RANGO expresion:exp2 DELIMFUNC listaSentencias:sentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS {:
	String nombre = id.getLexema().toUpperCase();
	// Se busca el símbolo en la Tabla de Símbolos
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	
	if(simbolosTabla.containsSymbol(nombre)) {
		TypeIF tipoIndice = simbolosTabla.getSymbol(nombre).getType();

		// El índice tiene que ser de tipo ENTERO
		if(!(tipoIndice instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semantico: indice " + nombre + " en sentencia FOR no es de tipo entero");
		}

		TypeIF tipoExp1 = exp1.getTipoExpresion();
		TypeIF tipoExp2 = exp2.getTipoExpresion();

		// Los dos tienen que ser de tipo ENTERO
		if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semantico: el rango en sentencia FOR debe ser de tipo entero");
		}

		SentenciaFor s = new SentenciaFor(sentencias.getSentencias());
		RESULT = s;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: indice " + nombre + " en sentencia FOR no esta declarado");
	}
:};

sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN:id RANGOBUCLEPARA expresion:exp1 RANGO expresion:exp2 DELIMFUNC listaSentenciasFuncion:sentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS {:
	String nombre = id.getLexema().toUpperCase();
	// Se busca el símbolo en la Tabla de Símbolos
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();

	if(simbolosTabla.containsSymbol(nombre)) {
		TypeIF tipoIndice = simbolosTabla.getSymbol(nombre).getType();

		// El índice tiene que ser de tipo ENTERO
		if(!(tipoIndice instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semantico: índice " + nombre + " en sentencia FOR no es de tipo entero");
		}

		TypeIF tipoExp1 = exp1.getTipoExpresion();
		TypeIF tipoExp2 = exp2.getTipoExpresion();

		// Los dos tienen que ser de tipo ENTERO
		if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semantico: el rango en sentencia FOR debe ser de tipo entero");
		}

		SentenciaFor s = new SentenciaFor(sentencias.getSentencias());
		RESULT = s;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: indice " + nombre + " en sentencia FOR no esta declarado");
	}
:};

// escribir
parametroEscribir ::= STRING:texto {:
	String cadena = texto.getLexema();

	ParametroEscribir param = new ParametroEscribir(cadena);
	RESULT = param;
:}
| expresion:exp {:
	TypeIF tipoExp1 = exp.getTipoExpresion();
	
	// Tiene que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semantico: tipo de la expresion en sentencia ESCRIBIR no es entero");
	}

	ParametroEscribir param = new ParametroEscribir(exp);
	RESULT = param;
:}
| epsilon {:
	ParametroEscribir param = new ParametroEscribir();
	RESULT = param;
:};

sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir:parametro PDERECHO DSENTENCIAS {:
	SentenciaEscribir s = new SentenciaEscribir();

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	
	if(parametro.isEsCadena()) {
		String label = Textos.addTexto(parametro.getCadena());
		cb.addQuadruple("WSTRING", label);
	} else if(parametro.isEsExpresion()) {
		cb.addQuadruples(parametro.getExpresion().getIntermediateCode());
		cb.addQuadruple("WINT", parametro.getExpresion().getTemporal());
	} else {
		cb.addQuadruple("WLN");
	}
	s.setIntermediateCode(cb.create());
	
	RESULT = s;
:};

// devolver
sentenciaDevolver ::= FRETURN expresion DSENTENCIAS {:

	// Recuperar el nombre del ámbito actual
	String nombre = scopeManager.getCurrentScope().getName().toUpperCase();
	TypeIF tipoSubprograma = scopeManager.searchType(nombre);

	SentenciaDevolver s = new SentenciaDevolver();
	RESULT = s;
:};
