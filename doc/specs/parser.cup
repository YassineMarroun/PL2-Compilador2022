package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;


// Declaración de no terminales

non terminal  							program;
non terminal Axiom						axiom;
non terminal  							epsilon;
non terminal  							defconstantes;
non terminal ValorConstante				valorconstante;
non terminal  							seccionconstantes;
non terminal  							deftipos;
non terminal TypeIF						tipovector;
non terminal ValorRango					valorango;
non terminal  							secciontipos;
non terminal  							defvariables;
non terminal TypeIF						tipovariable;
non terminal ListaVariables 			listavariables;
non terminal  							seccionvariables;
non terminal  							defsubprograma;
non terminal							puntoycomaopcional;

non terminal 							tiporetornofuncion;
non terminal  							seccionsubprograma;
non terminal  							defprincipal;
non terminal SelectorValorOReferencia	selectorvalororeferencia;

non terminal Expresion					expresion;
non terminal Expresion					expresionlvl2;
non terminal Expresion					expresionlvl3;
non terminal Expresion					expresionlvl4;
non terminal Expresion					expresionlvl5;

non terminal MiembroVector				miembrovector;
non terminal							procedimiento;
non terminal							funcion;
non terminal							selectorpof;

non terminal            				parametrofuncionoproc;
non terminal 							llamadafuncion; 

non terminal ParteIzquierdaAsignacion 	parteizquierdaasignacion;  
non terminal SentenciaDeAsignacion 		sentenciadeasignacion;

non terminal ParametroEscribir			parametroEscribir;
non terminal SentenciaEscribir			sentenciaEscribir;

non terminal Sentencia 					sentencia;
non terminal Sentencia					sentenciaFuncion;
non terminal ListaSentencias			listaSentencias;
non terminal ListaSentencias			listaSentenciasFuncion;
non terminal SentenciaIf 				sentenciaif;
non terminal SentenciaIf 				sentenciaifFuncion;
non terminal RellenoIf					rellenoif;
non terminal RellenoIf					rellenoifFuncion;
non terminal SentenciaFor 				sentenciafor;
non terminal SentenciaFor				sentenciaforFuncion;
non terminal SentenciaDevolver 			sentenciaDevolver;

non terminal Expresion					parametroasignacion;

non terminal SentenciaLlamadaFuncion	sentenciallamadafuncion;


// Declaración de relaciones de precedencia
precedence left		PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA ;
precedence left 	PRODUCTO;
precedence right	NOLOGICO;

// Declaración de reglas de producción

start with program;

program ::= 
{: 
	syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
:}
axiom:ax
{: 
  	// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  	// List intermediateCode = ax.getIntermediateCode ();
  	// finalCodeFactory.create (intermediateCode);

  	// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  	// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  	// aún no se tendrá implementada la generación de código intermedio ni final.
  	// Para la entrega final deberán descomentarse y usarse.
  		
  	syntaxErrorManager.syntaxInfo ("Parsing process ended.");
:};

axiom ::= defprincipal;

epsilon ::=;

// Definición de constantes
defconstantes ::= IDEN:id ASIGNACION valorconstante:valor DSENTENCIAS defconstantes {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	String nombre = id.getLexema().toUpperCase();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	
	// Comprobación unicidad
	if(simbolosTabla.containsSymbol(nombre)) {
		semanticErrorManager.semanticFatalError("Error semántico: identificador "+ nombre +" duplicado");
	}
	
	if(valor.isEsValorEntero()) {
		// Constante entera
		TypeIF tipo = tiposTabla.getType("ENTERO");
		int valorEntero = valor.getValorEntero();
		SymbolConstantEntero simboloConstante = new SymbolConstantEntero(ambito, nombre, tipo, valorEntero);
		simbolosTabla.addSymbol(simboloConstante);
	} else {
		// Constante lógica
		TypeIF tipo = tiposTabla.getType("LOGICO");
		boolean valorLogico = valor.getValorLogico();
		SymbolConstantLogico simboloConstante = new SymbolConstantLogico(ambito, nombre, tipo, valorLogico);
		simbolosTabla.addSymbol(simboloConstante);
	}
:}
	| epsilon; 

valorconstante ::= FALSO {: RESULT = new ValorConstante(false); :}
	| CIERTO {: RESULT = new ValorConstante(true); :} 
	| NUM:n {: RESULT = new ValorConstante(Integer.parseInt(n.getLexema())); :};

seccionconstantes ::= BCONSTANTES defconstantes | epsilon;

 // Definición de tipos
deftipos ::= IDEN:id ASIGNACION DECLVECTOR CIZQUIERDO valorango:valorn1 RANGO valorango:valorn2 CDERECHO ASIGNACIONVECTOR tipovector:tipo DSENTENCIAS deftipos {:
	String nombre = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	
	// Comprobación unicidad
	if(tiposTabla.containsType(nombre)) {
		semanticErrorManager.semanticFatalError("Error semántico: identificador del tipo " + nombre + " duplicado");
	}

	// Se recupera valor de rango1
	int rango1 = valorn1.getRangoVector();
	int rango2 = valorn2.getRangoVector();

	if(rango2 >= rango1) {
		TypeArray tipoArray = new TypeArray(ambito, nombre, rango1, rango2, tipo);
		tiposTabla.addType(tipoArray);
	} else {
		semanticErrorManager.semanticFatalError("Error semántico: el rango 2 del vector debe ser mayor o igual que el rango 1");
	}
:} 
	| epsilon;

tipovector ::= BOOLEANO {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	RESULT = tipo;
:} 
	| ENTERO {:
		ScopeIF ambito = scopeManager.getCurrentScope();
		TypeTableIF tiposTabla = ambito.getTypeTable();
		TypeIF tipo = tiposTabla.getType("ENTERO");
		RESULT = tipo;
	:};

valorango ::= NUM:n {:
	ValorRango vRango = new ValorRango(Integer.parseInt(n.getLexema()));
	RESULT = vRango;
:}
	| IDEN:id {:
		String nombre = id.getLexema().toUpperCase();
		// Se busca el símbolo en la Tabla de Símbolos
		ScopeIF ambito = scopeManager.getCurrentScope();
		SymbolTableIF simbolosTabla = ambito.getSymbolTable();
		
		if(simbolosTabla.containsSymbol(nombre)) {
			SymbolIF s = simbolosTabla.getSymbol(nombre);
			ValorRango vRango = new ValorRango(s);
			RESULT = vRango;
		} else {
			semanticErrorManager.semanticFatalError("Error semántico: identificador " + nombre + " no esta declarado");
		}
	:}
	| miembrovector:miembro {:
		ValorRango vRango = new ValorRango(miembro);
		RESULT = vRango;
	:};

secciontipos ::= COMIENZODECLTIPOS deftipos | epsilon; 

// Definición de variables
tipovariable ::= BOOLEANO {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	RESULT = tipo;
:}
	| ENTERO {:
		ScopeIF ambito = scopeManager.getCurrentScope();
		TypeTableIF tiposTabla = ambito.getTypeTable();
		TypeIF tipo = tiposTabla.getType("ENTERO");
		RESULT = tipo;
	
	:}
	| IDEN:id {:
		String nombreTipo = id.getLexema().toUpperCase();
		ScopeIF ambito = scopeManager.getCurrentScope();
		TypeTableIF tiposTabla = ambito.getTypeTable();

		if(tiposTabla.containsType(nombreTipo)) {
			TypeIF tipo = tiposTabla.getType(nombreTipo);
			RESULT = tipo;
		} else {
			semanticErrorManager.semanticFatalError("Error semántico: el tipo " + nombreTipo + " no está declarado");
		}
	:};

selectorvalororeferencia ::= PARAMETROVALOR IDEN:id {:
	String nombre = id.getLexema().toUpperCase();
	SelectorValorOReferencia selector = new SelectorValorOReferencia(nombre);
	RESULT = selector;
:}
	| expresion:exp {:
		SelectorValorOReferencia selector = new SelectorValorOReferencia(exp);
		RESULT = selector;
	:};

defvariables ::= listavariables:variables DELIMFUNC tipovariable:tipo puntoycomaopcional defvariables {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	ArrayList<SelectorValorOReferencia> identificadores = variables.getVariables();

	for(SelectorValorOReferencia selector : identificadores) {
		String nombre = selector.getExpresion().getIdentificador();
		
		// Comprobación unicidad
		if(simbolosTabla.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("Error semántico: identificador " + nombre + " duplicado");
		}
		SymbolVariable simbolo = new SymbolVariable(ambito, nombre, tipo);
		simbolosTabla.addSymbol(simbolo);
	}

	DefVariables defV = new DefVariables 
:}
	| epsilon; 

listavariables ::= selectorvalororeferencia:selector DIDENTIFICADORES listavariables:variables {:
	variables.addSelector(selector);
	RESULT = variables;
:}
	| selectorvalororeferencia:selector {:
		ListaVariables variables = new ListaVariables();
		variables.addSelector(selector);
		RESULT = variables;
	:}
	| epsilon {:
		ListaVariables variables = new ListaVariables();
		RESULT = variables;
	:};

seccionvariables ::= DECLVARIABLES defvariables | epsilon;
puntoycomaopcional ::= DSENTENCIAS | epsilon;

// Reglas de subprogramas
tiporetornofuncion ::= IDEN {:
:}
	| tipovector {:
	
	:};

procedimiento ::= COMIENZOPROCEDIMIENTO IDEN:id {:
	// Al acceder al id del procedimiento se tiene que abrir el ámbito
	String nombre = id.getLexema().toUpperCase();
	scopeManager.openScope(nombre);
	syntaxErrorManager.syntaxInfo("Ámbito procedimiento " + nombre + " abierto");
:} PIZQUIERDO defvariables PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias FINBLOQUESENTENCIAS DSENTENCIAS {:
	String nombre = id.getLexema().toUpperCase();

	scopeManager.closeScope();
	syntaxErrorManager.syntaxInfo("Ámbito procedimiento " + nombre + " cerrado");
:};

funcion ::= DECLAREFUNCION IDEN:id {:
	// Al acceder al id de la función se tiene que abrir el ámbito
	String nombre = id.getLexema().toUpperCase();
	scopeManager.openScope(nombre);
	syntaxErrorManager.syntaxInfo("Ámbito función " + nombre + " abierto");
:} PIZQUIERDO defvariables PDERECHO DELIMFUNC tiporetornofuncion DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS {:
	String nombre = id.getLexema().toUpperCase();

	scopeManager.closeScope();
	syntaxErrorManager.syntaxInfo("Ámbito función " + nombre + " cerrado");
:};

selectorpof ::= procedimiento | funcion;
defsubprograma ::= selectorpof defsubprograma | epsilon;
seccionsubprograma ::= COMIENZOSUBPROGRAMAS defsubprograma | epsilon;

// Definición de programa principal
defprincipal ::= COMIENZOPROGRAMA IDEN:id {:
	// Abrir ámbito principal
	String nombre = id.getLexema().toUpperCase();
	scopeManager.openScope(nombre);
	syntaxErrorManager.syntaxInfo("Ámbito principal " + nombre + " abierto");
	// Añadir tipos primitivos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeEntero entero = new TypeEntero(ambito);
	TypeLogico logico = new TypeLogico(ambito);
	TypeTableIF tiposTabla = ambito.getTypeTable();
	tiposTabla.addType(entero);
	tiposTabla.addType(logico);
:}
DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias FINBLOQUESENTENCIAS FINPROGRAMA;

expresion ::= expresion:exp1 MENORQUE expresion:exp2 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semántico: los dos operandos en < deben ser de tipo entero");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	RESULT = exp;
:}
	| expresion:exp1 IGUALDAD expresion:exp2 {:
		TypeIF tipoExp1 = exp1.getTipoExpresion();
		TypeIF tipoExp2 = exp2.getTipoExpresion();

		// Los dos tienen que ser de tipo ENTERO o los dos de tipo LOGICO
		if((!((tipoExp1 instanceof TypeEntero) && (tipoExp2 instanceof TypeEntero))) && (!((tipoExp1 instanceof TypeLogico) && (tipoExp2 instanceof TypeLogico)))) {
			semanticErrorManager.semanticFatalError("Error semántico:los dos operandos en == deben ser de tipo entero, o bien de tipo lógico");
		}

		// Se genera una expresión de tipo LOGICO
		ScopeIF ambito = scopeManager.getCurrentScope();
		TypeTableIF tiposTabla = ambito.getTypeTable();
		TypeIF tipo = tiposTabla.getType("LOGICO");
		Expresion exp = new Expresion(tipo);
		RESULT = exp;

	:}
	| IDEN:id {:
		String identificador = id.getLexema().toUpperCase();
		Expresion exp = new Expresion(identificador);
		RESULT = exp;
	:}
	| llamadafuncion {:
	
	:}
	| CIERTO {:
		ScopeIF ambito = scopeManager.getCurrentScope();
		TypeTableIF tiposTabla = ambito.getTypeTable();
		TypeIF tipo = tiposTabla.getType("LOGICO");
		Expresion exp = new Expresion(tipo);
		RESULT = exp;
	:}
	| FALSO {:
		ScopeIF ambito = scopeManager.getCurrentScope();
		TypeTableIF tiposTabla = ambito.getTypeTable();
		TypeIF tipo = tiposTabla.getType("LOGICO");
		Expresion exp = new Expresion(tipo);
		RESULT = exp;
	:}
	| miembrovector:mVector {:
		Expresion exp = new Expresion(mVector.getTipoMiembroVector());
		RESULT = exp;
	:}
	| NUM {:
		ScopeIF ambito = scopeManager.getCurrentScope();
		TypeTableIF tiposTabla = ambito.getTypeTable();
		TypeIF tipo = tiposTabla.getType("ENTERO");
		Expresion exp = new Expresion(tipo);
		RESULT = exp;
	:}
	| expresionlvl2:exp {:
		RESULT = exp;
	:};

expresionlvl2 ::= expresion:exp1 SUMA expresion:exp2 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semántico: los dos operandos en + deben ser de tipo entero");
	}

	// Se genera una expresión de tipo ENTERO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	Expresion exp = new Expresion(tipo);
	RESULT = exp;
:}
	| expresionlvl3:exp {:
		RESULT = exp;
	:};

expresionlvl3 ::= expresion:exp1 YLOGICA expresion:exp2 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo LOGICO
	if(!(tipoExp1 instanceof TypeLogico) || !(tipoExp2 instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semántico: los dos operandos en Y deben ser de tipo lógico");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	RESULT = exp;
:}
	| expresion:exp1 PRODUCTO expresion:exp2 {:
		TypeIF tipoExp1 = exp1.getTipoExpresion();
		TypeIF tipoExp2 = exp2.getTipoExpresion();

		// Los dos tienen que ser de tipo ENTERO
		if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semántico: los dos operandos en * deben ser de tipo entero");
		}

		// Se genera una expresión de tipo ENTERO
		ScopeIF ambito = scopeManager.getCurrentScope();
		TypeTableIF tiposTabla = ambito.getTypeTable();
		TypeIF tipo = tiposTabla.getType("ENTERO");
		Expresion exp = new Expresion(tipo);
		RESULT = exp;
	:}
	| expresionlvl4:exp {:
		RESULT = exp;
	:};

expresionlvl4 ::= NOLOGICO expresion:exp1 {:
	TypeIF tipoExp1 = exp1.getTipoExpresion();

	// Tiene que ser de tipo LOGICO
	if(!(tipoExp1 instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semántico: el operando en NO debe ser de tipo lógico");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	RESULT = exp;
:}
	| expresionlvl5:exp {:
		RESULT = exp;
	:};

expresionlvl5 ::= PIZQUIERDO expresion:exp PDERECHO {:
	RESULT = exp;
:}
	| CIZQUIERDO expresion:exp CDERECHO {:
		RESULT = exp;
	:};


// Acceso a vectores
miembrovector ::= IDEN:id CIZQUIERDO valorango:valorRango CDERECHO {:
	String identificador = id.getLexema().toUpperCase();
	MiembroVector m = new MiembroVector(identificador, valorRango);
	m.comprobarMiembroVector();
	RESULT = m;
:};
 
// Sentencias de asignación
parteizquierdaasignacion ::= IDEN:id {:
	String identificador = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	if(!simbolosTabla.containsSymbol(identificador)) {
		semanticErrorManager.semanticFatalError("Error semántico: identificador " + identificador + " no está declarado");
	}
	SymbolIF simbolo = simbolosTabla.getSymbol(identificador);
	ParteIzquierdaAsignacion parteIzquierda = new ParteIzquierdaAsignacion(simbolo.getType());
	RESULT = parteIzquierda;
:}
	| miembrovector:mVector {:
		ParteIzquierdaAsignacion parteIzquierda = new ParteIzquierdaAsignacion(mVector.getTipoMiembroVector());
		RESULT = parteIzquierda;
	:};

sentenciadeasignacion ::= parteizquierdaasignacion:parteIzquierda ASIGNACION parametroasignacion:exp DSENTENCIAS {:
	TypeIF tipoIzquierda = parteIzquierda.getTipoIzquierdo();
	TypeIF tipoParametro = exp.getTipoExpresion();

	// Los dos tienen que ser iguales
	if((tipoIzquierda instanceof TypeEntero && tipoParametro instanceof TypeEntero) || (tipoIzquierda instanceof TypeLogico && tipoParametro instanceof TypeLogico)) {
		SentenciaDeAsignacion sentencia = new SentenciaDeAsignacion();
		RESULT = sentencia;
	} else {
		semanticErrorManager.semanticFatalError("Error semántico: tipos incompatibles en la sentencia de asignación");
	}
:};

parametroasignacion ::= expresion:exp {:
	RESULT = exp;
:};

// Llamada a función
parametrofuncionoproc ::= listavariables;
llamadafuncion ::= IDEN PIZQUIERDO parametrofuncionoproc PDERECHO;  
sentenciallamadafuncion ::= llamadafuncion DSENTENCIAS;


// Sentencias
sentencia ::= sentenciadeasignacion:s {: RESULT = s; :}
	| sentenciaif:s {: RESULT = s; :}
	| sentenciafor:s {: RESULT = s; :}
	| sentenciaEscribir:s {: RESULT = s; :}
	| sentenciallamadafuncion:s {: RESULT = s; :};

sentenciaFuncion ::= sentenciadeasignacion | sentenciaifFuncion | sentenciaforFuncion | sentenciaEscribir | sentenciallamadafuncion | sentenciaDevolver;

listaSentencias ::= sentencia:s listaSentencias:lista {:
	lista.addSentencia(s);
	RESULT = lista;
:}
	| epsilon {:
		ListaSentencias lista = new ListaSentencias();
		RESULT = lista;
	:};

listaSentenciasFuncion ::= sentenciaFuncion:s listaSentenciasFuncion:lista {:
	lista.addSentencia(s);
	RESULT = lista;
:}
	| epsilon {:
		ListaSentencias lista = new ListaSentencias();
		RESULT = lista;
	:};

// if
sentenciaif ::= COMIENZOSI expresion:exp STARTIF DELIMFUNC listaSentencias:sentenciasIF rellenoif:relleno FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS {:
	TypeIF tipoExp = exp.getTipoExpresion();

	// Tiene que ser de tipo LOGICO
	if(!(tipoExp instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semántico: la expresión en sentencia IF debe ser de tipo lógico");
	}
	
	SentenciaIf s = new SentenciaIf(sentenciasIF.getSentencias(), relleno.getSentencias());
	RESULT = s;
:};

sentenciaifFuncion ::= COMIENZOSI expresion:exp STARTIF DELIMFUNC listaSentenciasFuncion:sentenciasIF rellenoifFuncion:relleno FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS {:
	TypeIF tipoExp = exp.getTipoExpresion();

	// Tiene que ser de tipo LOGICO
	if(!(tipoExp instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semántico: la expresión en sentencia IF debe ser de tipo lógico");
	}

	SentenciaIf s = new SentenciaIf(sentenciasIF.getSentencias(), relleno.getSentencias());
	RESULT = s;
:};

rellenoifFuncion ::= ALTERNATIVASI DELIMFUNC listaSentenciasFuncion:sentencias {:
	RellenoIf r = new RellenoIf(sentencias.getSentencias());
	RESULT = r;
:}
	| epsilon {:
		RellenoIf r = new RellenoIf();
		RESULT = r;
	:};

rellenoif ::= ALTERNATIVASI DELIMFUNC listaSentencias:sentencias {:
	RellenoIf r = new RellenoIf(sentencias.getSentencias());
	RESULT = r;
:}
	| epsilon {:
		RellenoIf r = new RellenoIf();
		RESULT = r;
	:};

// for 
sentenciafor ::= COMIENZOBUCLEPARA IDEN:id RANGOBUCLEPARA expresion:exp1 RANGO expresion:exp2 DELIMFUNC listaSentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS {:
	String nombre = id.getLexema().toUpperCase();
	// Se busca el símbolo en la Tabla de Símbolos
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	
	if(simbolosTabla.containsSymbol(nombre)) {
		TypeIF tipoIndice = simbolosTabla.getSymbol(nombre).getType();

		// El índice tiene que ser de tipo ENTERO
		if(!(tipoIndice instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semántico: índice " + nombre + " en sentencia FOR no es de tipo entero");
		}

		TypeIF tipoExp1 = exp1.getTipoExpresion();
		TypeIF tipoExp2 = exp2.getTipoExpresion();

		// Los dos tienen que ser de tipo ENTERO
		if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semántico: el rango en sentencia FOR debe ser de tipo entero");
		}

		SentenciaFor s = new SentenciaFor();
		RESULT = s;
	} else {
		semanticErrorManager.semanticFatalError("Error semántico: índice " + nombre + " en sentencia FOR no está declarado");
	}
:};

sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN:id RANGOBUCLEPARA expresion:exp1 RANGO expresion:exp2 DELIMFUNC listaSentenciasFuncion FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS {:
	String nombre = id.getLexema().toUpperCase();
	// Se busca el símbolo en la Tabla de Símbolos
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();

	if(simbolosTabla.containsSymbol(nombre)) {
		TypeIF tipoIndice = simbolosTabla.getSymbol(nombre).getType();

		// El índice tiene que ser de tipo ENTERO
		if(!(tipoIndice instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semántico: índice " + nombre + " en sentencia FOR no es de tipo entero");
		}

		TypeIF tipoExp1 = exp1.getTipoExpresion();
		TypeIF tipoExp2 = exp2.getTipoExpresion();

		// Los dos tienen que ser de tipo ENTERO
		if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semántico: el rango en sentencia FOR debe ser de tipo entero");
		}

		SentenciaFor s = new SentenciaFor();
		RESULT = s;
	} else {
		semanticErrorManager.semanticFatalError("Error semántico: índice " + nombre + " en sentencia FOR no está declarado");
	}
:};


// escribir
parametroEscribir ::= STRING:texto {:
	String cadena = texto.getLexema();

	ParametroEscribir param = new ParametroEscribir(cadena);
	RESULT = param;
:}
	| expresion:exp {:

		TypeIF tipoExp1 = exp.getTipoExpresion();
	
		// Tiene que ser de tipo ENTERO
		if(!(tipoExp1 instanceof TypeEntero)) {
				semanticErrorManager.semanticFatalError("Error semántico: tipo de la expresión en sentencia ESCRIBIR no es entero");
		}

		ParametroEscribir param = new ParametroEscribir(exp);
		RESULT = param;
	:}
	| epsilon {:
		ParametroEscribir param = new ParametroEscribir();
		RESULT = param;
	:};

sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir PDERECHO DSENTENCIAS {:
	SentenciaEscribir s = new SentenciaEscribir();
	RESULT = s;
:};

// devolver
sentenciaDevolver ::= FRETURN expresion DSENTENCIAS {:

	// Recuperar el nombre del ámbito actual
	String nombre = scopeManager.getCurrentScope().getName();
	ScopeIF ambitoPadre = scopeManager.getParentScope();
	TypeTableIF tiposTabla = ambitoPadre.getTypeTable();
	Type

	SentenciaDevolver s = new SentenciaDevolver();
	RESULT = s;
:};
