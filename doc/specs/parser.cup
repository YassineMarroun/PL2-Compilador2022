package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;


// Declaración de no terminales

non terminal  					program;
non terminal Axiom				axiom;
non terminal  					epsilon;
non terminal  					defconstantes;
non terminal ValorConstante		valorconstante;
non terminal  					seccionconstantes;
non terminal  					deftipos;
non terminal TypeIF				tipovector;
non terminal ValorRango			valorango;
non terminal  					secciontipos;
non terminal  					defvariables;
non terminal					tipovariable;
non terminal  					listavariables;
non terminal  					seccionvariables;
non terminal  					defsubprograma;
non terminal					puntoycomaopcional;

non terminal 					tiporetornofuncion;
non terminal  					seccionsubprograma;
non terminal  					defprincipal;
non terminal					selectorvalororeferencia;

non terminal					expresion;
non terminal					expresionlvl2;
non terminal					expresionlvl3;
non terminal					expresionlvl4;
non terminal					expresionlvl5;

non terminal					miembrovector;
non terminal					procedimiento;
non terminal					funcion;
non terminal					selectorpof;

non terminal            		parametrofuncionoproc;
non terminal 					llamadafuncion ; 

non terminal 					parteizquierdaasignacion;  
non terminal 					sentenciadeasignacion;

non terminal 					parametroEscribir ;
non terminal 					sentenciaEscribir ;

non terminal 					sentencia;
non terminal 					sentenciaFuncion;
non terminal 					listaSentencias;
non terminal 					listaSentenciasFuncion;
non terminal 					sentenciaif;
non terminal 					sentenciaifFuncion;
non terminal 					rellenoif;
non terminal 					rellenoifFuncion;
non terminal 					sentenciafor;
non terminal 					sentenciaforFuncion;
non terminal 					sentenciaDevolver;

non terminal					parametroasignacion;

non terminal					sentenciallamadafuncion;


// Declaración de relaciones de precedencia
precedence left		PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA ;
precedence left 	PRODUCTO;
precedence right	NOLOGICO;

// Declaración de reglas de producción

start with program;

program ::= 
{: 
	syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
:}
axiom:ax
{: 
  	// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  	//List intermediateCode = ax.getIntermediateCode ();
  	//finalCodeFactory.create (intermediateCode);

  	// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  	// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  	// aún no se tendrá implementada la generación de código intermedio ni final.
  	// Para la entrega final deberán descomentarse y usarse.
  		
  	syntaxErrorManager.syntaxInfo ("Parsing process ended.");
:};

axiom ::= defprincipal;

epsilon ::=;

//Definición de constantes
defconstantes ::= IDEN:id ASIGNACION valorconstante:valor DSENTENCIAS defconstantes {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	String nombre = id.getLexema().toUpperCase();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	
	// Comprobación unicidad
	if(simbolosTabla.containsSymbol(nombre)) {
		semanticErrorManager.semanticFatalError("Error semántico: identificador "+ nombre +" duplicado");
	}
	
	if(valor.isEsValorEntero()) {
		// Constante entera
		TypeIF tipo = tiposTabla.getType("ENTERO");
		int valorEntero = valor.getValorEntero();
		SymbolConstantEntero simboloConstante = new SymbolConstantEntero(ambito, nombre, tipo, valorEntero);
		simbolosTabla.addSymbol(simboloConstante);
	} else {
		// Constante lógica
		TypeIF tipo = tiposTabla.getType("LOGICO");
		boolean valorLogico = valor.getValorLogico();
		SymbolConstantLogico simboloConstante = new SymbolConstantLogico(ambito, nombre, tipo, valorLogico);
		simbolosTabla.addSymbol(simboloConstante);
	}
:}
	| epsilon; 

valorconstante ::= FALSO {: RESULT = new ValorConstante(false); :}
	| CIERTO {: RESULT = new ValorConstante(true); :} 
	| NUM:n {: RESULT = new ValorConstante(Integer.parseInt(n.getLexema())); :};

seccionconstantes ::= BCONSTANTES defconstantes | epsilon;

 //cDefinición de tipos
deftipos ::= IDEN:id ASIGNACION DECLVECTOR CIZQUIERDO valorango:valorn1 RANGO valorango:valorn2 CDERECHO ASIGNACIONVECTOR tipovector:tipo DSENTENCIAS deftipos {:
	String nombre = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	
	// Comprobación unicidad
	if(tiposTabla.containsType(nombre)) {
		semanticErrorManager.semanticFatalError("Error semántico: identificador del tipo " +  nombre + " duplicado");
	}

	// Se recupera valor de rango1
	int rango1 = valorn1.getRangoVector();
	int rango2 = valorn2.getRangoVector();

	if(rango2 >= rango1) {
		TypeArray tipoArray = new TypeArray(ambito, nombre, rango1, rango2, tipo);
		tiposTabla.addType(tipoArray);
	} else {
		semanticErrorManager.semanticFatalError("Error semántico: el rango 2 del vector debe ser mayor o igual que el rango 1");
	}
:} 
	| epsilon;

tipovector ::= BOOLEANO {:
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	RESULT = tipo;
:} 
	| ENTERO {:
		ScopeIF ambito = scopeManager.getCurrentScope();
		TypeTableIF tiposTabla = ambito.getTypeTable();
		TypeIF tipo = tiposTabla.getType("ENTERO");
		RESULT = tipo;
	:};

valorango ::= NUM:n  {:
	ValorRango vRango = new ValorRango(Integer.parseInt(n.getLexema()));
	RESULT = vRango;
:}
	| IDEN:id {:
		String nombre = id.getLexema().toUpperCase();
		// Se busca el símbolo en la Tabla de Símbolos
		ScopeIF ambito = scopeManager.getCurrentScope();
		SymbolTableIF simbolosTabla = ambito.getSymbolTable();
		if(simbolosTabla.containsSymbol(nombre)) {
			SymbolIF s = simbolosTabla.getSymbol(nombre);
			ValorRango vRango = new ValorRango(s);
			RESULT = vRango;
		} else {
			semanticErrorManager.semanticFatalError("Error semántico: identificador " + nombre + " no esta declarado");
		}
	:}
	| miembrovector {:
	
	:};

secciontipos ::= COMIENZODECLTIPOS deftipos | epsilon; 

// Definición de variables
tipovariable ::= BOOLEANO | ENTERO | IDEN ;
selectorvalororeferencia ::=  PARAMETROVALOR IDEN | expresion ;
defvariables ::= listavariables DELIMFUNC tipovariable puntoycomaopcional defvariables | epsilon; 
listavariables ::= selectorvalororeferencia DIDENTIFICADORES listavariables {:System.out.println("\n\n1\n\n");:} | selectorvalororeferencia {:System.out.println("\n\n2\n\n");:} | epsilon ;
seccionvariables ::= DECLVARIABLES defvariables | epsilon  ;
puntoycomaopcional ::= DSENTENCIAS | epsilon;

//reglas de subprogramas
tiporetornofuncion ::= IDEN | tipovector ;
procedimiento ::= COMIENZOPROCEDIMIENTO IDEN PIZQUIERDO defvariables PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias   FINBLOQUESENTENCIAS DSENTENCIAS ;
funcion ::= DECLAREFUNCION IDEN PIZQUIERDO defvariables PDERECHO DELIMFUNC tiporetornofuncion DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS  ;
selectorpof ::= procedimiento | funcion ;
defsubprograma ::=selectorpof  defsubprograma | epsilon ;
seccionsubprograma ::=COMIENZOSUBPROGRAMAS  defsubprograma  | epsilon ;

// Definición de programa principal
defprincipal ::= COMIENZOPROGRAMA IDEN:id {:
	// Abrir ámbito principal
	scopeManager.openScope(id.getLexema().toUpperCase());
	// Añadir tipos primitivos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeEntero entero = new TypeEntero(ambito);
	TypeLogico logico = new TypeLogico(ambito);
	TypeTableIF tiposTabla = ambito.getTypeTable();
	tiposTabla.addType(entero);
	tiposTabla.addType(logico);
:}
DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias FINBLOQUESENTENCIAS FINPROGRAMA;

expresion ::=  expresion MENORQUE  expresion
	|  expresion IGUALDAD  expresion
	| IDEN {:
	:}
	| llamadafuncion
	| CIERTO
	| FALSO
	| miembrovector
	| NUM
	| expresionlvl2;
expresionlvl2 ::=  expresion SUMA expresion | expresionlvl3;
expresionlvl3 ::=  expresion YLOGICA expresion |  expresion PRODUCTO expresion | expresionlvl4;
expresionlvl4 ::= NOLOGICO  expresion | expresionlvl5;
expresionlvl5 ::= PIZQUIERDO expresion PDERECHO | CIZQUIERDO expresion CDERECHO;


// Acceso a vectores
miembrovector::= IDEN CIZQUIERDO valorango CDERECHO;
 
// Sentencias de asignación
parteizquierdaasignacion ::= IDEN |miembrovector ;
sentenciadeasignacion ::= parteizquierdaasignacion ASIGNACION parametroasignacion DSENTENCIAS; 
parametroasignacion ::= expresion;

// Llamada a función
parametrofuncionoproc ::=     listavariables;
llamadafuncion ::= IDEN PIZQUIERDO parametrofuncionoproc PDERECHO;  
sentenciallamadafuncion ::= llamadafuncion DSENTENCIAS;


// Sentencias
sentencia ::= sentenciadeasignacion | sentenciaif | sentenciafor | sentenciaEscribir | sentenciallamadafuncion;
sentenciaFuncion ::= sentenciadeasignacion | sentenciaifFuncion | sentenciaforFuncion | sentenciaEscribir | sentenciallamadafuncion | sentenciaDevolver;
listaSentencias ::= sentencia  listaSentencias | epsilon;
listaSentenciasFuncion ::= sentenciaFuncion listaSentenciasFuncion | epsilon;

// if
sentenciaif ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentencias rellenoif  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS;
sentenciaifFuncion ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentenciasFuncion rellenoifFuncion  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS;
rellenoifFuncion ::=  ALTERNATIVASI DELIMFUNC  listaSentenciasFuncion | epsilon;
rellenoif ::=  ALTERNATIVASI DELIMFUNC  listaSentencias | epsilon;

// for 
sentenciafor ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;
sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentenciasFuncion FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;


// escribir
parametroEscribir ::= STRING | expresion | epsilon;
sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir PDERECHO DSENTENCIAS;

// devolver
sentenciaDevolver ::= FRETURN expresion DSENTENCIAS;
