package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	// Lista para guardar quadruplas de cadenas
	List<QuadrupleIF> listaCadenas = new ArrayList<QuadrupleIF>();

	// Variable para evitar que las instrucciones if-else tengan el mismo nombre
	int controlScope = 0;

	// Devuelve el tipo de la expresión
	public TypeIF getTypeExpresion(Expresion expresion) {
		
		// En caso de ser una expresión aritmética, será un entero
		if (expresion.getExAritmetica() != null) {
			return scopeManager.searchType("INTEGER");
		}
		
		// En caso de ser una expresión lógica, será un booleano
		if (expresion.getExLogica() != null) {
			return scopeManager.searchType("BOOLEAN");
		}
		
		// En caso de tener variables, se comprueba el tipo
		if (expresion.getVariables() != null) {
			if(scopeManager.searchSymbol(expresion.getVariables().getIdentificador()).getType() instanceof TypeArray) {
				TypeArray typeArray = (TypeArray)scopeManager.searchSymbol(expresion.getVariables().getIdentificador()).getType();
				return typeArray.getType();
			} else if(scopeManager.searchSymbol(expresion.getVariables().getIdentificador()).getType() instanceof TypeFunction) {
				SymbolFunction symbolFunction = (SymbolFunction)scopeManager.searchSymbol(expresion.getVariables().getIdentificador());
				TypeIF typeFunction = symbolFunction.getCabProcedure().getTipoRetorno().getIntOBool();
				return typeFunction;
			} else {
				return scopeManager.searchSymbol(expresion.getVariables().getIdentificador()).getType();
			}
		}
		return null;
	}

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;




// Declaración de no terminales


non terminal  				program;
non terminal Axiom			axiom;
non terminal  			epsilon;
non terminal  			defconstantes;
non terminal  			valorconstante;
non terminal  			seccionconstantes;
non terminal  			deftipos;
non terminal  			tipovector;
non terminal  			valorango;
non terminal  			secciontipos;
non terminal  			defvariables;
non terminal TypeIF			tipovariable;
non terminal  			listavariables;
non terminal  			seccionvariables;
non terminal  			defsubprograma;
non terminal			puntoycomaopcional;

non terminal 			tiporetornofuncion;
non terminal  			seccionsubprograma;
non terminal  			defprincipal;
non terminal			selectorvalororeferencia;


non terminal Expresion		expresion;
non terminal			expresionlvl2;
non terminal			expresionlvl3;
non terminal			expresionlvl4;
non terminal			expresionlvl5;



non terminal ExAritmetica 	exAritmetica;
non terminal ExLogica 		exLogica;
non terminal IdArray		idArray;
non terminal ParFuncion		parFuncion;
non terminal Parametros		parametros;
non terminal CabProcedure	cabProcedure;
non terminal TipoRetorno	tipoRetorno;
non terminal ProcParenParam	procParenParam;
non terminal ProcListParam	procListParam;
non terminal ProcParam		procParam;
non terminal CadIdVar		cadIdVar;
non terminal TipoRetorno	tipoRetorno;
non terminal Cuerpo			cuerpo;



non terminal			miembrovector;
non terminal			procedimiento;
non terminal			funcion;
non terminal			selectorpof;

non terminal            parametrofuncionoproc;
non terminal 			llamadafuncion ; 

non terminal 			parteizquierdaasignacion;  
non terminal 			sentenciadeasignacion;

non terminal 			parametroEscribir ;
non terminal 			sentenciaEscribir ;

non terminal 			sentencia;
non terminal 			sentenciaFuncion;
non terminal 			listaSentencias;
non terminal 			listaSentenciasFuncion;
non terminal 			sentenciaif;
non terminal 			sentenciaifFuncion;
non terminal 			rellenoif;
non terminal 			rellenoifFuncion;
non terminal 			sentenciafor;
non terminal 			sentenciaforFuncion;
non terminal 			sentenciaDevolver;


non terminal			parametroasignacion;

non terminal			sentenciallamadafuncion;





// Declaración de relaciones de precedencia
precedence left		PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA;
precedence left 	PRODUCTO;
precedence right	NOLOGICO;

// Declaración de reglas de producción

start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

axiom ::= defprincipal;

epsilon ::=;

//Definición de constantes
defconstantes ::=   IDEN ASIGNACION valorconstante DSENTENCIAS defconstantes | epsilon; 
valorconstante ::=   FALSO | CIERTO | NUM ;
seccionconstantes ::= BCONSTANTES defconstantes | epsilon;

 //Definición de tipos
deftipos ::=IDEN ASIGNACION DECLVECTOR CIZQUIERDO valorango RANGO valorango CDERECHO ASIGNACIONVECTOR tipovector  DSENTENCIAS deftipos | epsilon;
tipovector ::=BOOLEANO | ENTERO ;
valorango ::= NUM | IDEN | miembrovector;
secciontipos ::= COMIENZODECLTIPOS deftipos | epsilon; 

// Definición de variables
tipovariable ::= BOOLEANO | ENTERO | IDEN ;
selectorvalororeferencia ::=  PARAMETROVALOR IDEN |expresion ;
defvariables ::= listavariables DELIMFUNC tipovariable puntoycomaopcional defvariables | epsilon; 
listavariables ::= selectorvalororeferencia DIDENTIFICADORES listavariables {:System.out.println("\n\n1\n\n");:}| selectorvalororeferencia {:System.out.println("\n\n2\n\n");:}| epsilon ;
seccionvariables ::= DECLVARIABLES defvariables | epsilon  ;
puntoycomaopcional ::= DSENTENCIAS | epsilon;

//reglas de subprogramas
tiporetornofuncion ::= IDEN | tipovector ;
procedimiento ::= COMIENZOPROCEDIMIENTO IDEN PIZQUIERDO defvariables PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias   FINBLOQUESENTENCIAS DSENTENCIAS ;
funcion ::= DECLAREFUNCION IDEN PIZQUIERDO defvariables PDERECHO DELIMFUNC tiporetornofuncion DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS  ;
selectorpof ::= procedimiento | funcion ;
defsubprograma ::=selectorpof  defsubprograma | epsilon ;
seccionsubprograma ::=COMIENZOSUBPROGRAMAS  defsubprograma  | epsilon ;

// Definición de programa principal
defprincipal ::= COMIENZOPROGRAMA IDEN DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias FINBLOQUESENTENCIAS FINPROGRAMA ;

expresion ::=  expresion MENORQUE  expresion |  expresion IGUALDAD  expresion | IDEN | llamadafuncion | CIERTO | FALSO | miembrovector | NUM | expresionlvl2;
expresionlvl2 ::=  expresion SUMA expresion | expresionlvl3 ;
expresionlvl3 ::=  expresion YLOGICA expresion |  expresion PRODUCTO expresion | expresionlvl4;
expresionlvl4 ::= NOLOGICO  expresion | expresionlvl5 ;
expresionlvl5 ::= PIZQUIERDO expresion PDERECHO | CIZQUIERDO expresion CDERECHO  ;


// Acceso a vectores
miembrovector::= IDEN CIZQUIERDO valorango CDERECHO;
 
// sentencias de asignacion
parteizquierdaasignacion ::= IDEN |miembrovector  ;
sentenciadeasignacion ::= parteizquierdaasignacion ASIGNACION parametroasignacion DSENTENCIAS; 
parametroasignacion ::= expresion ;

// llamada a función
parametrofuncionoproc ::=     listavariables ;
llamadafuncion ::= IDEN PIZQUIERDO parametrofuncionoproc PDERECHO;  
sentenciallamadafuncion ::= llamadafuncion DSENTENCIAS;


// Sentencias
sentencia ::= sentenciadeasignacion | sentenciaif | sentenciafor | sentenciaEscribir | sentenciallamadafuncion ;
sentenciaFuncion ::= sentenciadeasignacion | sentenciaifFuncion | sentenciaforFuncion | sentenciaEscribir | sentenciallamadafuncion | sentenciaDevolver;
listaSentencias ::= sentencia  listaSentencias | epsilon;
listaSentenciasFuncion ::= sentenciaFuncion listaSentenciasFuncion | epsilon;

// if
sentenciaif ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentencias rellenoif  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
sentenciaifFuncion ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentenciasFuncion rellenoifFuncion  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
rellenoifFuncion ::=  ALTERNATIVASI DELIMFUNC  listaSentenciasFuncion | epsilon ;
rellenoif ::=  ALTERNATIVASI DELIMFUNC  listaSentencias | epsilon ;

// for 
sentenciafor ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;
sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentenciasFuncion FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;


// escribir. 
parametroEscribir ::= STRING | expresion | epsilon ;
sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir PDERECHO DSENTENCIAS;

// devolver
sentenciaDevolver ::= FRETURN expresion DSENTENCIAS;



