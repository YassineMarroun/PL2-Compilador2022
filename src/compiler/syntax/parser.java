
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon May 09 22:33:49 CEST 2022
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import java.util.Map.Entry;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon May 09 22:33:49 CEST 2022
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\147\000\002\002\004\000\002\062\002\000\002\002" +
    "\004\000\002\003\003\000\002\004\002\000\002\005\007" +
    "\000\002\005\003\000\002\006\003\000\002\006\003\000" +
    "\002\006\003\000\002\007\004\000\002\007\003\000\002" +
    "\010\016\000\002\010\003\000\002\011\003\000\002\011" +
    "\003\000\002\012\003\000\002\012\003\000\002\012\003" +
    "\000\002\013\004\000\002\013\003\000\002\015\003\000" +
    "\002\015\003\000\002\015\003\000\002\025\004\000\002" +
    "\025\003\000\002\014\007\000\002\014\003\000\002\016" +
    "\005\000\002\016\003\000\002\016\003\000\002\017\004" +
    "\000\002\017\003\000\002\021\003\000\002\021\003\000" +
    "\002\022\003\000\002\022\003\000\002\063\002\000\002" +
    "\034\022\000\002\064\002\000\002\035\024\000\002\036" +
    "\003\000\002\036\003\000\002\020\004\000\002\020\003" +
    "\000\002\023\004\000\002\023\003\000\002\065\002\000" +
    "\002\024\016\000\002\026\005\000\002\026\005\000\002" +
    "\026\003\000\002\026\003\000\002\026\003\000\002\026" +
    "\003\000\002\026\003\000\002\026\003\000\002\026\003" +
    "\000\002\027\005\000\002\027\003\000\002\030\005\000" +
    "\002\030\005\000\002\030\003\000\002\031\004\000\002" +
    "\031\003\000\002\032\005\000\002\032\005\000\002\033" +
    "\006\000\002\041\003\000\002\041\003\000\002\042\006" +
    "\000\002\060\003\000\002\037\003\000\002\040\006\000" +
    "\002\061\004\000\002\045\003\000\002\045\003\000\002" +
    "\045\003\000\002\045\003\000\002\045\003\000\002\046" +
    "\003\000\002\046\003\000\002\046\003\000\002\046\003" +
    "\000\002\046\003\000\002\046\003\000\002\047\004\000" +
    "\002\047\003\000\002\050\004\000\002\050\003\000\002" +
    "\051\013\000\002\052\013\000\002\054\005\000\002\054" +
    "\003\000\002\053\005\000\002\053\003\000\002\055\015" +
    "\000\002\056\015\000\002\043\003\000\002\043\003\000" +
    "\002\043\003\000\002\044\007\000\002\057\005" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\354\000\004\011\000\001\002\000\004\002\356\001" +
    "\002\000\004\011\010\001\002\000\004\002\uffff\001\002" +
    "\000\004\002\ufffe\001\002\000\004\024\011\001\002\000" +
    "\004\052\uffd2\001\002\000\004\052\013\001\002\000\014" +
    "\027\ufffd\041\ufffd\042\ufffd\045\015\050\ufffd\001\002\000" +
    "\012\027\ufffd\041\ufffd\042\031\050\ufffd\001\002\000\014" +
    "\024\020\027\ufffd\041\ufffd\042\ufffd\050\ufffd\001\002\000" +
    "\012\027\ufff6\041\ufff6\042\ufff6\050\ufff6\001\002\000\012" +
    "\027\ufff7\041\ufff7\042\ufff7\050\ufff7\001\002\000\004\055" +
    "\022\001\002\000\012\027\ufffb\041\ufffb\042\ufffb\050\ufffb" +
    "\001\002\000\010\031\026\035\024\047\023\001\002\000" +
    "\004\053\ufff8\001\002\000\004\053\ufff9\001\002\000\004" +
    "\053\027\001\002\000\004\053\ufffa\001\002\000\014\024" +
    "\020\027\ufffd\041\ufffd\042\ufffd\050\ufffd\001\002\000\012" +
    "\027\ufffc\041\ufffc\042\ufffc\050\ufffc\001\002\000\012\024" +
    "\341\027\ufffd\041\ufffd\050\ufffd\001\002\000\010\027\035" +
    "\041\ufffd\050\ufffd\001\002\000\010\027\uffed\041\uffed\050" +
    "\uffed\001\002\000\006\041\130\050\ufffd\001\002\000\030" +
    "\007\051\021\056\024\046\031\053\032\054\033\037\035" +
    "\040\041\ufffd\047\052\050\ufffd\052\ufffd\001\002\000\006" +
    "\041\uffe1\050\uffe1\001\002\000\020\007\051\021\056\024" +
    "\046\031\053\033\037\035\040\047\052\001\002\000\032" +
    "\004\uffcc\006\uffcc\023\uffcc\025\uffcc\034\uffcc\037\uffcc\040" +
    "\uffcc\043\uffcc\051\uffcc\052\uffcc\053\uffcc\054\uffcc\001\002" +
    "\000\006\041\uffe2\050\uffe2\001\002\000\004\052\115\001" +
    "\002\000\022\025\072\034\uffe8\037\073\040\070\043\uffe8" +
    "\051\067\052\uffe8\054\071\001\002\000\032\004\uffc1\006" +
    "\uffc1\023\uffc1\025\uffc1\034\uffc1\037\uffc1\040\uffc1\043\uffc1" +
    "\051\uffc1\052\uffc1\053\uffc1\054\uffc1\001\002\000\032\004" +
    "\uffc3\006\uffc3\023\uffc3\025\uffc3\034\uffc3\037\uffc3\040\uffc3" +
    "\043\uffc3\051\uffc3\052\uffc3\053\uffc3\054\uffc3\001\002\000" +
    "\036\004\uffce\006\uffce\021\104\023\uffce\025\uffce\033\103" +
    "\034\uffce\037\uffce\040\uffce\043\uffce\051\uffce\052\uffce\053" +
    "\uffce\054\uffce\001\002\000\032\004\uffc6\006\uffc6\023\uffc6" +
    "\025\uffc6\034\uffc6\037\uffc6\040\uffc6\043\uffc6\051\uffc6\052" +
    "\uffc6\053\uffc6\054\uffc6\001\002\000\032\004\uffc8\006\uffc8" +
    "\023\uffc8\025\uffc8\034\uffc8\037\uffc8\040\uffc8\043\uffc8\051" +
    "\uffc8\052\uffc8\053\uffc8\054\uffc8\001\002\000\020\007\051" +
    "\021\056\024\046\031\053\033\037\035\040\047\052\001" +
    "\002\000\032\004\uffc9\006\uffc9\023\uffc9\025\uffc9\034\uffc9" +
    "\037\uffc9\040\uffc9\043\uffc9\051\uffc9\052\uffc9\053\uffc9\054" +
    "\uffc9\001\002\000\032\004\uffcb\006\uffcb\023\uffcb\025\uffcb" +
    "\034\uffcb\037\uffcb\040\uffcb\043\uffcb\051\uffcb\052\uffcb\053" +
    "\uffcb\054\uffcb\001\002\000\004\024\101\001\002\000\032" +
    "\004\uffcd\006\uffcd\023\uffcd\025\uffcd\034\uffcd\037\uffcd\040" +
    "\uffcd\043\uffcd\051\uffcd\052\uffcd\053\uffcd\054\uffcd\001\002" +
    "\000\020\007\051\021\056\024\046\031\053\033\037\035" +
    "\040\047\052\001\002\000\010\034\uffe4\043\062\052\uffe4" +
    "\001\002\000\032\004\uffca\006\uffca\023\uffca\025\uffca\034" +
    "\uffca\037\uffca\040\uffca\043\uffca\051\uffca\052\uffca\053\uffca" +
    "\054\uffca\001\002\000\012\034\uffe6\041\uffe6\050\uffe6\052" +
    "\uffe3\001\002\000\026\007\051\021\056\024\046\031\053" +
    "\032\054\033\037\034\ufffd\035\040\047\052\052\ufffd\001" +
    "\002\000\006\034\uffe5\052\uffe5\001\002\000\006\034\uffe3" +
    "\052\uffe3\001\002\000\016\023\066\025\072\037\073\040" +
    "\070\051\067\054\071\001\002\000\032\004\uffbf\006\uffbf" +
    "\023\uffbf\025\uffbf\034\uffbf\037\uffbf\040\uffbf\043\uffbf\051" +
    "\uffbf\052\uffbf\053\uffbf\054\uffbf\001\002\000\020\007\051" +
    "\021\056\024\046\031\053\033\037\035\040\047\052\001" +
    "\002\000\020\007\051\021\056\024\046\031\053\033\037" +
    "\035\040\047\052\001\002\000\020\007\051\021\056\024" +
    "\046\031\053\033\037\035\040\047\052\001\002\000\020" +
    "\007\051\021\056\024\046\031\053\033\037\035\040\047" +
    "\052\001\002\000\020\007\051\021\056\024\046\031\053" +
    "\033\037\035\040\047\052\001\002\000\032\004\uffc4\006" +
    "\uffc4\023\uffc4\025\uffc4\034\uffc4\037\uffc4\040\uffc4\043\uffc4" +
    "\051\uffc4\052\uffc4\053\uffc4\054\uffc4\001\002\000\032\004" +
    "\uffcf\006\uffcf\023\uffcf\025\uffcf\034\uffcf\037\073\040\uffcf" +
    "\043\uffcf\051\uffcf\052\uffcf\053\uffcf\054\uffcf\001\002\000" +
    "\032\004\uffd0\006\uffd0\023\uffd0\025\uffd0\034\uffd0\037\073" +
    "\040\uffd0\043\uffd0\051\uffd0\052\uffd0\053\uffd0\054\uffd0\001" +
    "\002\000\032\004\uffc7\006\uffc7\023\uffc7\025\uffc7\034\uffc7" +
    "\037\073\040\uffc7\043\uffc7\051\uffc7\052\uffc7\053\uffc7\054" +
    "\uffc7\001\002\000\032\004\uffc5\006\uffc5\023\uffc5\025\uffc5" +
    "\034\uffc5\037\073\040\uffc5\043\uffc5\051\uffc5\052\uffc5\053" +
    "\uffc5\054\uffc5\001\002\000\010\034\uffe9\043\uffe9\052\uffe9" +
    "\001\002\000\032\004\uffc2\006\uffc2\023\uffc2\025\uffc2\034" +
    "\uffc2\037\uffc2\040\uffc2\043\uffc2\051\uffc2\052\uffc2\053\uffc2" +
    "\054\uffc2\001\002\000\024\007\051\021\056\024\046\031" +
    "\053\032\054\033\037\034\ufffd\035\040\047\052\001\002" +
    "\000\006\024\110\047\105\001\002\000\006\004\ufff1\023" +
    "\ufff1\001\002\000\006\004\uffef\023\uffef\001\002\000\004" +
    "\023\111\001\002\000\010\004\ufff0\021\104\023\ufff0\001" +
    "\002\000\034\004\uffbe\006\uffbe\023\uffbe\025\uffbe\034\uffbe" +
    "\037\uffbe\040\uffbe\043\uffbe\051\uffbe\052\uffbe\053\uffbe\054" +
    "\uffbe\055\uffbe\001\002\000\004\034\114\001\002\000\004" +
    "\034\uffb9\001\002\000\032\004\uffb8\006\uffb8\023\uffb8\025" +
    "\uffb8\034\uffb8\037\uffb8\040\uffb8\043\uffb8\051\uffb8\052\uffb8" +
    "\053\uffb8\054\uffb8\001\002\000\010\012\120\016\121\024" +
    "\116\001\002\000\034\007\uffea\021\uffea\024\uffea\031\uffea" +
    "\032\uffea\033\uffea\034\uffea\035\uffea\041\uffea\047\uffea\050" +
    "\uffea\052\uffea\053\uffea\001\002\000\034\007\ufffd\021\ufffd" +
    "\024\ufffd\031\ufffd\032\ufffd\033\ufffd\034\ufffd\035\ufffd\041" +
    "\ufffd\047\ufffd\050\ufffd\052\ufffd\053\122\001\002\000\034" +
    "\007\uffeb\021\uffeb\024\uffeb\031\uffeb\032\uffeb\033\uffeb\034" +
    "\uffeb\035\uffeb\041\uffeb\047\uffeb\050\uffeb\052\uffeb\053\uffeb" +
    "\001\002\000\034\007\uffec\021\uffec\024\uffec\031\uffec\032" +
    "\uffec\033\uffec\034\uffec\035\uffec\041\uffec\047\uffec\050\uffec" +
    "\052\uffec\053\uffec\001\002\000\032\007\uffe0\021\uffe0\024" +
    "\uffe0\031\uffe0\032\uffe0\033\uffe0\034\uffe0\035\uffe0\041\uffe0" +
    "\047\uffe0\050\uffe0\052\uffe0\001\002\000\032\007\051\021" +
    "\056\024\046\031\053\032\054\033\037\034\ufffd\035\040" +
    "\041\ufffd\047\052\050\ufffd\052\ufffd\001\002\000\032\007" +
    "\uffdf\021\uffdf\024\uffdf\031\uffdf\032\uffdf\033\uffdf\034\uffdf" +
    "\035\uffdf\041\uffdf\047\uffdf\050\uffdf\052\uffdf\001\002\000" +
    "\010\034\uffe7\041\uffe7\050\uffe7\001\002\000\016\025\072" +
    "\034\127\037\073\040\070\051\067\054\071\001\002\000" +
    "\032\004\uffc0\006\uffc0\023\uffc0\025\uffc0\034\uffc0\037\uffc0" +
    "\040\uffc0\043\uffc0\051\uffc0\052\uffc0\053\uffc0\054\uffc0\001" +
    "\002\000\010\014\222\022\220\050\ufffd\001\002\000\004" +
    "\050\133\001\002\000\004\050\uffd3\001\002\000\014\013" +
    "\ufffd\015\134\017\141\024\140\046\142\001\002\000\004" +
    "\024\206\001\002\000\016\013\uffb6\015\uffb6\017\uffb6\024" +
    "\uffb6\026\uffb6\046\uffb6\001\002\000\004\013\204\001\002" +
    "\000\016\013\ufffd\015\134\017\141\024\140\026\ufffd\046" +
    "\142\001\002\000\010\021\104\033\103\055\uffbd\001\002" +
    "\000\020\007\051\021\056\024\046\031\053\033\037\035" +
    "\040\047\052\001\002\000\004\033\160\001\002\000\004" +
    "\055\154\001\002\000\016\013\uffb3\015\uffb3\017\uffb3\024" +
    "\uffb3\026\uffb3\046\uffb3\001\002\000\016\013\uffb4\015\uffb4" +
    "\017\uffb4\024\uffb4\026\uffb4\046\uffb4\001\002\000\016\013" +
    "\uffb5\015\uffb5\017\uffb5\024\uffb5\026\uffb5\046\uffb5\001\002" +
    "\000\004\053\153\001\002\000\006\013\uffaa\026\uffaa\001" +
    "\002\000\004\055\uffbc\001\002\000\016\013\uffb2\015\uffb2" +
    "\017\uffb2\024\uffb2\026\uffb2\046\uffb2\001\002\000\020\010" +
    "\uffb7\013\uffb7\015\uffb7\017\uffb7\024\uffb7\026\uffb7\046\uffb7" +
    "\001\002\000\020\007\051\021\056\024\046\031\053\033" +
    "\037\035\040\047\052\001\002\000\004\053\157\001\002" +
    "\000\016\025\072\037\073\040\070\051\067\053\uffba\054" +
    "\071\001\002\000\020\010\uffbb\013\uffbb\015\uffbb\017\uffbb" +
    "\024\uffbb\026\uffbb\046\uffbb\001\002\000\024\007\051\021" +
    "\056\024\046\030\161\031\053\033\037\034\ufffd\035\040" +
    "\047\052\001\002\000\004\034\uff9f\001\002\000\016\025" +
    "\072\034\uff9e\037\073\040\070\051\067\054\071\001\002" +
    "\000\004\034\165\001\002\000\004\034\uff9d\001\002\000" +
    "\004\053\166\001\002\000\020\010\uff9c\013\uff9c\015\uff9c" +
    "\017\uff9c\024\uff9c\026\uff9c\046\uff9c\001\002\000\016\006" +
    "\170\025\072\037\073\040\070\051\067\054\071\001\002" +
    "\000\004\052\171\001\002\000\016\013\ufffd\015\134\017" +
    "\141\024\140\026\ufffd\046\142\001\002\000\006\013\ufffd" +
    "\026\174\001\002\000\004\013\200\001\002\000\004\052" +
    "\176\001\002\000\004\013\uffa2\001\002\000\014\013\ufffd" +
    "\015\134\017\141\024\140\046\142\001\002\000\004\013" +
    "\uffa3\001\002\000\004\017\201\001\002\000\004\053\202" +
    "\001\002\000\016\013\uffa7\015\uffa7\017\uffa7\024\uffa7\026" +
    "\uffa7\046\uffa7\001\002\000\006\013\uffab\026\uffab\001\002" +
    "\000\004\044\205\001\002\000\004\002\uffd1\001\002\000" +
    "\004\036\207\001\002\000\020\007\051\021\056\024\046" +
    "\031\053\033\037\035\040\047\052\001\002\000\016\004" +
    "\211\025\072\037\073\040\070\051\067\054\071\001\002" +
    "\000\020\007\051\021\056\024\046\031\053\033\037\035" +
    "\040\047\052\001\002\000\016\025\072\037\073\040\070" +
    "\051\067\052\213\054\071\001\002\000\014\013\ufffd\015" +
    "\134\017\141\024\140\046\142\001\002\000\004\013\215" +
    "\001\002\000\004\015\216\001\002\000\004\053\217\001" +
    "\002\000\016\013\uffa1\015\uffa1\017\uffa1\024\uffa1\026\uffa1" +
    "\046\uffa1\001\002\000\004\024\247\001\002\000\004\050" +
    "\uffd4\001\002\000\004\024\230\001\002\000\010\014\uffd8" +
    "\022\uffd8\050\uffd8\001\002\000\010\014\uffd7\022\uffd7\050" +
    "\uffd7\001\002\000\010\014\222\022\220\050\ufffd\001\002" +
    "\000\004\050\uffd5\001\002\000\004\050\uffd6\001\002\000" +
    "\004\033\uffdc\001\002\000\004\033\232\001\002\000\026" +
    "\007\051\021\056\024\046\031\053\032\054\033\037\034" +
    "\ufffd\035\040\047\052\052\ufffd\001\002\000\004\034\234" +
    "\001\002\000\004\052\235\001\002\000\014\027\ufffd\041" +
    "\ufffd\042\ufffd\045\015\050\ufffd\001\002\000\012\027\ufffd" +
    "\041\ufffd\042\031\050\ufffd\001\002\000\010\027\035\041" +
    "\ufffd\050\ufffd\001\002\000\006\041\130\050\ufffd\001\002" +
    "\000\004\050\242\001\002\000\012\015\134\017\141\024" +
    "\140\046\142\001\002\000\014\013\ufffd\015\134\017\141" +
    "\024\140\046\142\001\002\000\004\013\245\001\002\000" +
    "\004\053\246\001\002\000\010\014\uffdb\022\uffdb\050\uffdb" +
    "\001\002\000\004\033\uffda\001\002\000\004\033\251\001" +
    "\002\000\026\007\051\021\056\024\046\031\053\032\054" +
    "\033\037\034\ufffd\035\040\047\052\052\ufffd\001\002\000" +
    "\004\034\253\001\002\000\004\052\254\001\002\000\010" +
    "\012\261\016\260\024\256\001\002\000\004\052\262\001" +
    "\002\000\004\052\uffde\001\002\000\004\052\uffdd\001\002" +
    "\000\006\052\ufff3\053\ufff3\001\002\000\006\052\ufff2\053" +
    "\ufff2\001\002\000\014\027\ufffd\041\ufffd\042\ufffd\045\015" +
    "\050\ufffd\001\002\000\012\027\ufffd\041\ufffd\042\031\050" +
    "\ufffd\001\002\000\010\027\035\041\ufffd\050\ufffd\001\002" +
    "\000\006\041\130\050\ufffd\001\002\000\004\050\267\001" +
    "\002\000\014\010\300\015\270\017\273\024\140\046\142" +
    "\001\002\000\004\024\326\001\002\000\020\010\uffaf\013" +
    "\uffaf\015\uffaf\017\uffaf\024\uffaf\026\uffaf\046\uffaf\001\002" +
    "\000\020\010\uffb1\013\uffb1\015\uffb1\017\uffb1\024\uffb1\026" +
    "\uffb1\046\uffb1\001\002\000\020\007\051\021\056\024\046" +
    "\031\053\033\037\035\040\047\052\001\002\000\020\010" +
    "\uffac\013\uffac\015\uffac\017\uffac\024\uffac\026\uffac\046\uffac" +
    "\001\002\000\020\010\uffb0\013\uffb0\015\uffb0\017\uffb0\024" +
    "\uffb0\026\uffb0\046\uffb0\001\002\000\020\010\uffae\013\uffae" +
    "\015\uffae\017\uffae\024\uffae\026\uffae\046\uffae\001\002\000" +
    "\016\010\300\013\ufffd\015\270\017\273\024\140\046\142" +
    "\001\002\000\020\007\051\021\056\024\046\031\053\033" +
    "\037\035\040\047\052\001\002\000\020\010\uffad\013\uffad" +
    "\015\uffad\017\uffad\024\uffad\026\uffad\046\uffad\001\002\000" +
    "\016\025\072\037\073\040\070\051\067\053\303\054\071" +
    "\001\002\000\020\010\uff9b\013\uff9b\015\uff9b\017\uff9b\024" +
    "\uff9b\026\uff9b\046\uff9b\001\002\000\004\013\310\001\002" +
    "\000\020\010\300\013\ufffd\015\270\017\273\024\140\026" +
    "\ufffd\046\142\001\002\000\006\013\uffa8\026\uffa8\001\002" +
    "\000\006\013\uffa9\026\uffa9\001\002\000\004\053\311\001" +
    "\002\000\010\014\uffd9\022\uffd9\050\uffd9\001\002\000\016" +
    "\006\313\025\072\037\073\040\070\051\067\054\071\001" +
    "\002\000\004\052\314\001\002\000\020\010\300\013\ufffd" +
    "\015\270\017\273\024\140\026\ufffd\046\142\001\002\000" +
    "\006\013\ufffd\026\316\001\002\000\004\052\324\001\002" +
    "\000\004\013\321\001\002\000\004\013\uffa4\001\002\000" +
    "\004\017\322\001\002\000\004\053\323\001\002\000\020" +
    "\010\uffa6\013\uffa6\015\uffa6\017\uffa6\024\uffa6\026\uffa6\046" +
    "\uffa6\001\002\000\016\010\300\013\ufffd\015\270\017\273" +
    "\024\140\046\142\001\002\000\004\013\uffa5\001\002\000" +
    "\004\036\327\001\002\000\020\007\051\021\056\024\046" +
    "\031\053\033\037\035\040\047\052\001\002\000\016\004" +
    "\331\025\072\037\073\040\070\051\067\054\071\001\002" +
    "\000\020\007\051\021\056\024\046\031\053\033\037\035" +
    "\040\047\052\001\002\000\016\025\072\037\073\040\070" +
    "\051\067\052\333\054\071\001\002\000\016\010\300\013" +
    "\ufffd\015\270\017\273\024\140\046\142\001\002\000\004" +
    "\013\335\001\002\000\004\015\336\001\002\000\004\053" +
    "\337\001\002\000\020\010\uffa0\013\uffa0\015\uffa0\017\uffa0" +
    "\024\uffa0\026\uffa0\046\uffa0\001\002\000\010\027\uffee\041" +
    "\uffee\050\uffee\001\002\000\004\055\343\001\002\000\010" +
    "\027\ufff4\041\ufff4\050\ufff4\001\002\000\004\020\344\001" +
    "\002\000\004\021\345\001\002\000\006\024\110\047\105" +
    "\001\002\000\004\004\347\001\002\000\006\024\110\047" +
    "\105\001\002\000\004\023\351\001\002\000\004\005\352" +
    "\001\002\000\006\012\261\016\260\001\002\000\004\053" +
    "\354\001\002\000\012\024\341\027\ufffd\041\ufffd\050\ufffd" +
    "\001\002\000\010\027\ufff5\041\ufff5\050\ufff5\001\002\000" +
    "\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\354\000\006\002\003\062\004\001\001\000\002\001" +
    "\001\000\006\003\005\024\006\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\065\011\001" +
    "\001\000\002\001\001\000\006\004\015\007\013\001\001" +
    "\000\006\004\032\013\031\001\001\000\006\004\020\005" +
    "\016\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\006\024\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\004\020\005\027\001\001\000\002\001" +
    "\001\000\006\004\341\010\337\001\001\000\006\004\035" +
    "\017\033\001\001\000\002\001\001\000\006\004\131\023" +
    "\130\001\001\000\030\004\060\014\040\016\041\025\056" +
    "\026\042\027\047\030\046\031\044\032\043\033\057\040" +
    "\054\001\001\000\002\001\001\000\020\026\125\027\047" +
    "\030\046\031\044\032\043\033\057\040\054\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\020\026\101" +
    "\027\047\030\046\031\044\032\043\033\057\040\054\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\026\064\027\047\030\046\031" +
    "\044\032\043\033\057\040\054\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\026\004\063\016" +
    "\062\025\056\026\042\027\047\030\046\031\044\032\043" +
    "\033\057\040\054\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\020\026\077" +
    "\027\047\030\046\031\044\032\043\033\057\040\054\001" +
    "\001\000\020\026\076\027\047\030\046\031\044\032\043" +
    "\033\057\040\054\001\001\000\020\026\075\027\047\030" +
    "\046\031\044\032\043\033\057\040\054\001\001\000\020" +
    "\026\074\027\047\030\046\031\044\032\043\033\057\040" +
    "\054\001\001\000\020\026\073\027\047\030\046\031\044" +
    "\032\043\033\057\040\054\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\030\004" +
    "\063\016\112\025\056\026\042\027\047\030\046\031\044" +
    "\032\043\033\057\037\111\040\054\001\001\000\006\012" +
    "\106\033\105\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\015\116\001\001\000\002\001\001\000\006\004\123\021" +
    "\122\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\030\004\060\014\124\016\041\025\056\026" +
    "\042\027\047\030\046\031\044\032\043\033\057\040\054" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\004\225\020\220\034\222" +
    "\035\223\036\224\001\001\000\002\001\001\000\002\001" +
    "\001\000\030\004\147\033\150\040\146\041\142\042\134" +
    "\044\143\045\136\047\135\051\145\055\144\061\151\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\030\004\147\033\150\040\146\041\142\042\134\044" +
    "\143\045\136\047\202\051\145\055\144\061\151\001\001" +
    "\000\002\001\001\000\020\026\166\027\047\030\046\031" +
    "\044\032\043\033\057\040\054\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\022\026" +
    "\155\027\047\030\046\031\044\032\043\033\057\040\054" +
    "\060\154\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\004\163\026\161\027\047\030\046" +
    "\031\044\032\043\033\057\040\054\043\162\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\030\004\147\033\150\040\146" +
    "\041\142\042\134\044\143\045\136\047\171\051\145\055" +
    "\144\061\151\001\001\000\006\004\174\053\172\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\030\004\147\033\150\040\146\041\142\042\134\044\143" +
    "\045\136\047\176\051\145\055\144\061\151\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\020\026\207\027\047\030\046" +
    "\031\044\032\043\033\057\040\054\001\001\000\002\001" +
    "\001\000\020\026\211\027\047\030\046\031\044\032\043" +
    "\033\057\040\054\001\001\000\002\001\001\000\030\004" +
    "\147\033\150\040\146\041\142\042\134\044\143\045\136" +
    "\047\213\051\145\055\144\061\151\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\014\004\225\020\226" +
    "\034\222\035\223\036\224\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\063\230\001\001\000\002\001\001" +
    "\000\030\004\060\014\232\016\041\025\056\026\042\027" +
    "\047\030\046\031\044\032\043\033\057\040\054\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\004\015\007" +
    "\235\001\001\000\006\004\032\013\236\001\001\000\006" +
    "\004\035\017\237\001\001\000\006\004\131\023\240\001" +
    "\001\000\002\001\001\000\024\033\150\040\146\041\142" +
    "\042\134\044\143\045\242\051\145\055\144\061\151\001" +
    "\001\000\030\004\147\033\150\040\146\041\142\042\134" +
    "\044\143\045\136\047\243\051\145\055\144\061\151\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\064\247\001\001\000\002\001\001\000\030\004" +
    "\060\014\251\016\041\025\056\026\042\027\047\030\046" +
    "\031\044\032\043\033\057\040\054\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\011\256\022\254\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\004\015\007\262" +
    "\001\001\000\006\004\032\013\263\001\001\000\006\004" +
    "\035\017\264\001\001\000\006\004\131\023\265\001\001" +
    "\000\002\001\001\000\026\033\150\040\146\041\142\042" +
    "\271\044\275\046\276\052\274\056\270\057\273\061\300" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\020\026\311\027\047\030\046\031\044\032\043" +
    "\033\057\040\054\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\032\004\305\033\150\040\146" +
    "\041\142\042\271\044\275\046\304\050\303\052\274\056" +
    "\270\057\273\061\300\001\001\000\020\026\301\027\047" +
    "\030\046\031\044\032\043\033\057\040\054\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\032\004\305\033\150\040\146\041\142\042" +
    "\271\044\275\046\304\050\306\052\274\056\270\057\273" +
    "\061\300\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\032\004\305\033\150\040\146\041\142\042" +
    "\271\044\275\046\304\050\314\052\274\056\270\057\273" +
    "\061\300\001\001\000\006\004\317\054\316\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\032\004" +
    "\305\033\150\040\146\041\142\042\271\044\275\046\304" +
    "\050\324\052\274\056\270\057\273\061\300\001\001\000" +
    "\002\001\001\000\002\001\001\000\020\026\327\027\047" +
    "\030\046\031\044\032\043\033\057\040\054\001\001\000" +
    "\002\001\001\000\020\026\331\027\047\030\046\031\044" +
    "\032\043\033\057\040\054\001\001\000\002\001\001\000" +
    "\032\004\305\033\150\040\146\041\142\042\271\044\275" +
    "\046\304\050\333\052\274\056\270\057\273\061\300\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\012\345\033\105\001\001\000\002\001\001\000\006\012" +
    "\347\033\105\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\011\352\001\001\000\002\001\001\000\006\004" +
    "\341\010\354\001\001\000\002\001\001\000\002\001\001" +
    "" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // sentenciaDevolver ::= FRETURN expresion DSENTENCIAS 
            {
              SentenciaDevolver RESULT =null;
		

	// Recuperar el nombre del ámbito actual
	String nombre = scopeManager.getCurrentScope().getName().toUpperCase();
	TypeIF tipoSubprograma = scopeManager.searchType(nombre);

	SentenciaDevolver s = new SentenciaDevolver();
	RESULT = s;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaDevolver",45, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir PDERECHO DSENTENCIAS 
            {
              SentenciaEscribir RESULT =null;
		int parametroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int parametroright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ParametroEscribir parametro = (ParametroEscribir)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
	SentenciaEscribir s = new SentenciaEscribir();

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	
	if(parametro.isEsCadena()) {
		String label = Textos.addTexto(parametro.getCadena());
		cb.addQuadruple("WSTRING", label);
	} else if(parametro.isEsExpresion()) {
		cb.addQuadruples(parametro.getExpresion().getIntermediateCode());
		cb.addQuadruple("WINT", parametro.getExpresion().getTemporal());
	} else {
		cb.addQuadruple("WLN");
	}
	s.setIntermediateCode(cb.create());
	
	RESULT = s;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaEscribir",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // parametroEscribir ::= epsilon 
            {
              ParametroEscribir RESULT =null;
		
	ParametroEscribir param = new ParametroEscribir();
	RESULT = param;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametroEscribir",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // parametroEscribir ::= expresion 
            {
              ParametroEscribir RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	TypeIF tipoExp1 = exp.getTipoExpresion();
	
	// Tiene que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semantico: tipo de la expresion en sentencia ESCRIBIR no es entero");
	}

	ParametroEscribir param = new ParametroEscribir(exp);
	RESULT = param;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametroEscribir",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // parametroEscribir ::= STRING 
            {
              ParametroEscribir RESULT =null;
		int textoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int textoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token texto = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String cadena = texto.getLexema();

	ParametroEscribir param = new ParametroEscribir(cadena);
	RESULT = param;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametroEscribir",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentenciasFuncion FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS 
            {
              SentenciaFor RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-9)).value;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ListaSentencias sentencias = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		
	String nombre = id.getLexema().toUpperCase();
	// Se busca el símbolo en la Tabla de Símbolos
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();

	if(simbolosTabla.containsSymbol(nombre)) {
		TypeIF tipoIndice = simbolosTabla.getSymbol(nombre).getType();

		// El índice tiene que ser de tipo ENTERO
		if(!(tipoIndice instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semantico: índice " + nombre + " en sentencia FOR no es de tipo entero");
		}

		TypeIF tipoExp1 = exp1.getTipoExpresion();
		TypeIF tipoExp2 = exp2.getTipoExpresion();

		// Los dos tienen que ser de tipo ENTERO
		if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semantico: el rango en sentencia FOR debe ser de tipo entero");
		}

		SentenciaFor s = new SentenciaFor(sentencias.getSentencias());
		RESULT = s;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: indice " + nombre + " en sentencia FOR no esta declarado");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaforFuncion",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // sentenciafor ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS 
            {
              SentenciaFor RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-9)).value;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ListaSentencias sentencias = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		
	String nombre = id.getLexema().toUpperCase();
	// Se busca el símbolo en la Tabla de Símbolos
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	
	if(simbolosTabla.containsSymbol(nombre)) {
		TypeIF tipoIndice = simbolosTabla.getSymbol(nombre).getType();
		SymbolIF simboloIndice = simbolosTabla.getSymbol(nombre);

		// El índice tiene que ser de tipo ENTERO
		if(!(tipoIndice instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semantico: indice " + nombre + " en sentencia FOR no es de tipo entero");
		}

		TypeIF tipoExp1 = exp1.getTipoExpresion();
		TypeIF tipoExp2 = exp2.getTipoExpresion();

		// Los dos tienen que ser de tipo ENTERO
		if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
			semanticErrorManager.semanticFatalError("Error semantico: el rango en sentencia FOR debe ser de tipo entero");
		}

		SentenciaFor s = new SentenciaFor(sentencias.getSentencias());

		// CÓDIGO INTERMEDIO
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
		TemporalFactory tF = new TemporalFactory(ambito);
		LabelFactoryIF lF = new LabelFactory();
		LabelIF labelInicio = lF.create();
		LabelIF labelFin = lF.create();
		TemporalIF tempDireccion = tF.create();
		cb.addQuadruples(exp1.getIntermediateCode());
		cb.addQuadruple("MVA", tempDireccion, new Variable((SymbolVariable)simboloIndice));
		cb.addQuadruple("STP", tempDireccion, exp1.getTemporal());
		cb.addQuadruples(exp2.getIntermediateCode());
		TemporalIF tempComparacion = tF.create();
		cb.addQuadruple("INLABEL", labelInicio);
		cb.addQuadruple("GR", tempComparacion, exp1.getTemporal(), exp2.getTemporal());
		cb.addQuadruple("BRTRUE", tempComparacion, labelFin);
		cb.addQuadruples(sentencias.getIntermediateCode());
		// Incremento de la variable
		cb.addQuadruple("ADD", exp1.getTemporal(), exp1.getTemporal(), 1);
		cb.addQuadruple("STP", tempDireccion, exp1.getTemporal());
		cb.addQuadruple("BR", labelInicio);
		cb.addQuadruple("INLABEL", labelFin);
		s.setIntermediateCode(cb.create());

		RESULT = s;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: indice " + nombre + " en sentencia FOR no esta declarado");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciafor",43, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // rellenoif ::= epsilon 
            {
              RellenoIf RESULT =null;
		
	RellenoIf r = new RellenoIf();
	RESULT = r;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rellenoif",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // rellenoif ::= ALTERNATIVASI DELIMFUNC listaSentencias 
            {
              RellenoIf RESULT =null;
		int sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaSentencias sentencias = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RellenoIf r = new RellenoIf(sentencias.getSentencias());
	RESULT = r;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rellenoif",41, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // rellenoifFuncion ::= epsilon 
            {
              RellenoIf RESULT =null;
		
	RellenoIf r = new RellenoIf();
	RESULT = r;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rellenoifFuncion",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // rellenoifFuncion ::= ALTERNATIVASI DELIMFUNC listaSentenciasFuncion 
            {
              RellenoIf RESULT =null;
		int sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaSentencias sentencias = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RellenoIf r = new RellenoIf(sentencias.getSentencias());

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	cb.addQuadruples(sentencias.getIntermediateCode());
	r.setIntermediateCode(cb.create());

	RESULT = r;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("rellenoifFuncion",42, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // sentenciaifFuncion ::= COMIENZOSI expresion STARTIF DELIMFUNC listaSentenciasFuncion rellenoifFuncion FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS 
            {
              SentenciaIf RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int sentenciasIFleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int sentenciasIFright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		ListaSentencias sentenciasIF = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int rellenoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int rellenoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		RellenoIf relleno = (RellenoIf)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		
	TypeIF tipoExp = exp.getTipoExpresion();

	// Tiene que ser de tipo LOGICO
	if(!(tipoExp instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semántico: la expresión en sentencia IF debe ser de tipo lógico");
	}

	SentenciaIf s = new SentenciaIf(sentenciasIF.getSentencias(), relleno.getSentencias());
	RESULT = s;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaifFuncion",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // sentenciaif ::= COMIENZOSI expresion STARTIF DELIMFUNC listaSentencias rellenoif FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS 
            {
              SentenciaIf RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int sentenciasIFleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int sentenciasIFright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		ListaSentencias sentenciasIF = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int rellenoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int rellenoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		RellenoIf relleno = (RellenoIf)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		
	TypeIF tipoExp = exp.getTipoExpresion();

	// Tiene que ser de tipo LOGICO
	if(!(tipoExp instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semántico: la expresión en sentencia IF debe ser de tipo lógico");
	}

	SentenciaIf s = new SentenciaIf(sentenciasIF.getSentencias(), relleno.getSentencias());
	
	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	LabelFactoryIF lF = new LabelFactory();
	LabelIF labelVerdadero = lF.create();
	LabelIF labelFin = lF.create();
	cb.addQuadruples(exp.getIntermediateCode());
	// Si es CIERTO la etiqueta if
	cb.addQuadruple("BRTRUE", exp.getTemporal(), labelVerdadero);
	// Código FALSE
	cb.addQuadruples(relleno.getIntermediateCode());
	cb.addQuadruple("BR", labelFin);
	cb.addQuadruple("INLABEL", labelVerdadero);
	cb.addQuadruples(sentenciasIF.getIntermediateCode());
	cb.addQuadruple("INLABEL", labelFin);
	s.setIntermediateCode(cb.create());

	RESULT = s;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaif",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // listaSentenciasFuncion ::= epsilon 
            {
              ListaSentencias RESULT =null;
		
	ListaSentencias lista = new ListaSentencias();
	RESULT = lista;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaSentenciasFuncion",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // listaSentenciasFuncion ::= sentenciaFuncion listaSentenciasFuncion 
            {
              ListaSentencias RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sentencia s = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaSentencias lista = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	lista.addSentencia(s);

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	cb.addQuadruples(s.getIntermediateCode());
	cb.addQuadruples(lista.getIntermediateCode());
	lista.setIntermediateCode(cb.create());

	RESULT = lista;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaSentenciasFuncion",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // listaSentencias ::= epsilon 
            {
              ListaSentencias RESULT =null;
		
	ListaSentencias lista = new ListaSentencias();
	RESULT = lista;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaSentencias",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // listaSentencias ::= sentencia listaSentencias 
            {
              ListaSentencias RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sentencia s = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaSentencias lista = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	lista.addSentencia(s);
	
	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	cb.addQuadruples(s.getIntermediateCode());
	cb.addQuadruples(lista.getIntermediateCode());
	lista.setIntermediateCode(cb.create());

	RESULT = lista;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaSentencias",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentenciaFuncion ::= sentenciaDevolver 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaDevolver s = (SentenciaDevolver)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentenciaFuncion ::= sentenciallamadafuncion 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaLlamadaFuncion s = (SentenciaLlamadaFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // sentenciaFuncion ::= sentenciaEscribir 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaEscribir s = (SentenciaEscribir)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // sentenciaFuncion ::= sentenciaforFuncion 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaFor s = (SentenciaFor)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // sentenciaFuncion ::= sentenciaifFuncion 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaIf s = (SentenciaIf)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // sentenciaFuncion ::= sentenciadeasignacion 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaDeAsignacion s = (SentenciaDeAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaFuncion",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // sentencia ::= sentenciallamadafuncion 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaLlamadaFuncion s = (SentenciaLlamadaFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // sentencia ::= sentenciaEscribir 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaEscribir s = (SentenciaEscribir)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // sentencia ::= sentenciafor 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaFor s = (SentenciaFor)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // sentencia ::= sentenciaif 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaIf s = (SentenciaIf)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentencia ::= sentenciadeasignacion 
            {
              Sentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaDeAsignacion s = (SentenciaDeAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // sentenciallamadafuncion ::= llamadafuncion DSENTENCIAS 
            {
              SentenciaLlamadaFuncion RESULT =null;
		
	SentenciaLlamadaFuncion s = new SentenciaLlamadaFuncion();
	RESULT = s;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciallamadafuncion",47, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // llamadafuncion ::= IDEN PIZQUIERDO parametrofuncionoproc PDERECHO 
            {
              LlamadaFuncion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListaVariables parametros = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	String nombre = id.getLexema().toUpperCase();
	// Se busca el tipo nombre en la Tabla de Tipos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	System.out.println(tiposTabla);
	TypeIF tipo = tiposTabla.getType(nombre);

	if(tipo != null) {
		// El tipo tiene que ser una función
		if(tipo instanceof TypeProcedure) {
			LlamadaFuncion llamada = new LlamadaFuncion((TypeProcedure)tipo, parametros.getVariables());
			llamada.comprobarLlamada();
			RESULT = llamada;
		} else {
			semanticErrorManager.semanticFatalError("Error semantico: " + nombre + " no es un subprograma");
		}
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: no existe la funcion " + nombre);
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamadafuncion",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // parametrofuncionoproc ::= listavariables 
            {
              ListaVariables RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaVariables lista = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = lista;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametrofuncionoproc",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // parametroasignacion ::= expresion 
            {
              Expresion RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametroasignacion",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // sentenciadeasignacion ::= parteizquierdaasignacion ASIGNACION parametroasignacion DSENTENCIAS 
            {
              SentenciaDeAsignacion RESULT =null;
		int parteIzquierdaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int parteIzquierdaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ParteIzquierdaAsignacion parteIzquierda = (ParteIzquierdaAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	TypeIF tipoIzquierda = parteIzquierda.getTipoIzquierdo();
	TypeIF tipoParametro = exp.getTipoExpresion();

	// Los dos tienen que ser iguales
	if((tipoIzquierda instanceof TypeEntero && tipoParametro instanceof TypeEntero) || (tipoIzquierda instanceof TypeLogico && tipoParametro instanceof TypeLogico)) {
		SentenciaDeAsignacion sentencia = new SentenciaDeAsignacion();
		
		// CÓDIGO INTERMEDIO
		ScopeIF ambito = scopeManager.getCurrentScope();
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
		TemporalFactory tF = new TemporalFactory(ambito);
		TemporalIF temp = tF.create();
		cb.addQuadruples(exp.getIntermediateCode());
		cb.addQuadruples(parteIzquierda.getIntermediateCode());
		cb.addQuadruple("STP", parteIzquierda.getTemporal(), exp.getTemporal());
		sentencia.setIntermediateCode(cb.create());

		RESULT = sentencia;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: tipos incompatibles en la sentencia de asignacion");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciadeasignacion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // parteizquierdaasignacion ::= miembrovector 
            {
              ParteIzquierdaAsignacion RESULT =null;
		int mVectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mVectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		MiembroVector mVector = (MiembroVector)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ParteIzquierdaAsignacion parteIzquierda = new ParteIzquierdaAsignacion(mVector.getTipoMiembroVector());
	
	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(mVector.getIntermediateCode());
	parteIzquierda.setIntermediateCode(cb.create());
	parteIzquierda.setTemporal(mVector.getTemporal());
	
	RESULT = parteIzquierda;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parteizquierdaasignacion",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // parteizquierdaasignacion ::= IDEN 
            {
              ParteIzquierdaAsignacion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String identificador = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	if(!simbolosTabla.containsSymbol(identificador)) {
		semanticErrorManager.semanticFatalError("Error semantico: identificador " + identificador + " no esta declarado");
	}
	SymbolIF simbolo = simbolosTabla.getSymbol(identificador);
	ParteIzquierdaAsignacion parteIzquierda = new ParteIzquierdaAsignacion(simbolo.getType());
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruple("MVA", temp, new Variable((SymbolVariable)simbolo));
	parteIzquierda.setIntermediateCode(cb.create());
	parteIzquierda.setTemporal(temp);
	
	RESULT = parteIzquierda;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parteizquierdaasignacion",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // miembrovector ::= IDEN CIZQUIERDO valorango CDERECHO 
            {
              MiembroVector RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valorRangoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valorRangoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ValorRango valorRango = (ValorRango)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	String identificador = id.getLexema().toUpperCase();
	MiembroVector m = new MiembroVector(identificador, valorRango);
	m.comprobarMiembroVector();

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	cb.addQuadruples(valorRango.getIntermediateCode());
	TemporalIF temp = tF.create();
	TemporalIF tempBase = tF.create();
	TemporalIF tempAddress = tF.create();
	// Desplazamiento
	int rango1 = m.getTipoVector().getRango1();
	cb.addQuadruple("SUB", temp, valorRango.getTemporal(), rango1);
	SymbolIF simbolo = m.getSimbolo();
	cb.addQuadruple("MVA", tempBase, new Variable((SymbolVariable)simbolo));
	cb.addQuadruple("ADD", tempAddress, tempBase, temp);
	m.setIntermediateCode(cb.create());
	m.setTemporal(tempAddress);

	RESULT = m;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("miembrovector",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // expresionlvl5 ::= CIZQUIERDO expresion CDERECHO 
            {
              Expresion RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl5",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // expresionlvl5 ::= PIZQUIERDO expresion PDERECHO 
            {
              Expresion RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl5",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // expresionlvl4 ::= expresionlvl5 
            {
              Expresion RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl4",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // expresionlvl4 ::= NOLOGICO expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	TypeIF tipoExp1 = exp1.getTipoExpresion();

	// Tiene que ser de tipo LOGICO
	if(!(tipoExp1 instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semantico: el operando en NO debe ser de tipo logico");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruple("NOT", temp, exp1.getTemporal());
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl4",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // expresionlvl3 ::= expresionlvl4 
            {
              Expresion RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl3",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // expresionlvl3 ::= expresion PRODUCTO expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semantico: los dos operandos en * deben ser de tipo entero");
	}

	// Se genera una expresión de tipo ENTERO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	TemporalIF tempEx1 = exp1.getTemporal();
	TemporalIF tempEx2 = exp2.getTemporal();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("MUL", temp, tempEx1, tempEx2);
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);
	
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl3",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // expresionlvl3 ::= expresion YLOGICA expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo LOGICO
	if(!(tipoExp1 instanceof TypeLogico) || !(tipoExp2 instanceof TypeLogico)) {
		semanticErrorManager.semanticFatalError("Error semantico: los dos operandos en Y deben ser de tipo logico");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("AND", temp, exp1.getTemporal(), exp2.getTemporal());
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);
	
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl3",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // expresionlvl2 ::= expresionlvl3 
            {
              Expresion RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl2",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // expresionlvl2 ::= expresion SUMA expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semantico: los dos operandos en + deben ser de tipo entero");
	}

	// Se genera una expresión de tipo ENTERO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	Expresion exp = new Expresion(tipo);

	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	TemporalIF tempEx1 = exp1.getTemporal();
	TemporalIF tempEx2 = exp2.getTemporal();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("ADD", temp, tempEx1, tempEx2);
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresionlvl2",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // expresion ::= expresionlvl2 
            {
              Expresion RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // expresion ::= NUM 
            {
              Expresion RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	int num = Integer.parseInt(n.getLexema());
	Expresion exp = new Expresion(tipo);

	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruple("MV", temp, new Value(num));
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // expresion ::= miembrovector 
            {
              Expresion RESULT =null;
		int mVectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mVectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		MiembroVector mVector = (MiembroVector)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	Expresion exp = new Expresion(mVector.getTipoMiembroVector());

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(mVector.getIntermediateCode());
	cb.addQuadruple("MVP", temp, mVector.getTemporal());
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // expresion ::= FALSO 
            {
              Expresion RESULT =null;
		
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);

	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruple("MV", temp, new Value(0));
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // expresion ::= CIERTO 
            {
              Expresion RESULT =null;
		
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruple("MV", temp, new Value(1));
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);
	
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // expresion ::= llamadafuncion 
            {
              Expresion RESULT =null;
		int llamadaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int llamadaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LlamadaFuncion llamada = (LlamadaFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// Tiene que ser una función
	TypeProcedure tipo = llamada.getTipoSubprograma();
	if(tipo instanceof TypeFunction) {
		TypeIF tipoRetorno = ((TypeFunction)tipo).getTipoRetorno();
		Expresion exp = new Expresion(tipoRetorno);
		RESULT = exp;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: expresion de llamada a funcion debe ser una funcion");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // expresion ::= IDEN 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String identificador = id.getLexema().toUpperCase();
	Expresion exp = new Expresion(identificador);

	// CÓDIGO INTERMEDIO
	if(scopeManager.containsSymbol(identificador)) {
		SymbolIF simboloID = scopeManager.searchSymbol(identificador);
		ScopeIF ambito = scopeManager.getCurrentScope();
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
		TemporalFactory tF = new TemporalFactory(ambito);
		TemporalIF temp = tF.create();

		// Es una variable
		if(simboloID instanceof SymbolVariable) {
			TemporalIF tempMVP = tF.create();
			cb.addQuadruple("MVA", temp, new Variable((SymbolVariable)simboloID));
			cb.addQuadruple("MVP", tempMVP, temp);
			exp.setTemporal(tempMVP);
		}
		// Es una constante de tipo ENTERO
		else if (simboloID instanceof SymbolConstantEntero) {
			int num = ((SymbolConstantEntero)simboloID).getValorEntero();
			cb.addQuadruple("MV", temp, new Value(num));
			exp.setTemporal(temp);
		}
		// Es una contante de tipo LÓGICO
		else {
			boolean logico = ((SymbolConstantLogico)simboloID).getValorLogico();
			if(logico) {
				cb.addQuadruple("MV", temp, new Value(1));
				exp.setTemporal(temp);
			} else {
				cb.addQuadruple("MV", temp, new Value(0));
				exp.setTemporal(temp);
			}
		}
		exp.setIntermediateCode(cb.create());
	}
	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // expresion ::= expresion IGUALDAD expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO o los dos de tipo LOGICO
	if((!((tipoExp1 instanceof TypeEntero) && (tipoExp2 instanceof TypeEntero))) && (!((tipoExp1 instanceof TypeLogico) && (tipoExp2 instanceof TypeLogico)))) {
		semanticErrorManager.semanticFatalError("Error semantico:los dos operandos en == deben ser de tipo entero, o bien de tipo logico");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);
	
	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("EQ", temp, exp1.getTemporal(), exp2.getTemporal());
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);
	
	RESULT = exp;


              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // expresion ::= expresion MENORQUE expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	TypeIF tipoExp1 = exp1.getTipoExpresion();
	TypeIF tipoExp2 = exp2.getTipoExpresion();

	// Los dos tienen que ser de tipo ENTERO
	if(!(tipoExp1 instanceof TypeEntero) || !(tipoExp2 instanceof TypeEntero)) {
		semanticErrorManager.semanticFatalError("Error semantico: los dos operandos en < deben ser de tipo entero");
	}

	// Se genera una expresión de tipo LOGICO
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	Expresion exp = new Expresion(tipo);

	// CÓDIGO INTERMEDIO
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruples(exp1.getIntermediateCode());
	cb.addQuadruples(exp2.getIntermediateCode());
	cb.addQuadruple("LS", temp, exp1.getTemporal(), exp2.getTemporal());
	exp.setIntermediateCode(cb.create());
	exp.setTemporal(temp);

	RESULT = exp;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // defprincipal ::= COMIENZOPROGRAMA IDEN NT$3 DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias FINBLOQUESENTENCIAS FINPROGRAMA 
            {
              DefPrincipal RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (DefPrincipal) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-9)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-10)).value;
		int sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ListaSentencias sentencias = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
	DefPrincipal defP = new DefPrincipal();

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	cb.addQuadruples(sentencias.getIntermediateCode());
	defP.setIntermediateCode(cb.create());

	RESULT = defP;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defprincipal",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // NT$3 ::= 
            {
              DefPrincipal RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	// Abrir ámbito principal
	String nombre = id.getLexema().toUpperCase();
	scopeManager.openScope(nombre);
	syntaxErrorManager.syntaxInfo("Ambito principal " + nombre + " abierto");
	// Añadir tipos primitivos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeEntero entero = new TypeEntero(ambito);
	TypeLogico logico = new TypeLogico(ambito);
	TypeTableIF tiposTabla = ambito.getTypeTable();
	tiposTabla.addType(entero);
	tiposTabla.addType(logico);

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",51, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // seccionsubprograma ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionsubprograma",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // seccionsubprograma ::= COMIENZOSUBPROGRAMAS defsubprograma 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionsubprograma",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // defsubprograma ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defsubprograma",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // defsubprograma ::= selectorpof defsubprograma 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defsubprograma",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // selectorpof ::= funcion 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorpof",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // selectorpof ::= procedimiento 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorpof",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // funcion ::= DECLAREFUNCION IDEN NT$2 PIZQUIERDO defvariables PDERECHO DELIMFUNC tiporetornofuncion DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-15)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-16)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-16)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-16)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-13)).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-13)).right;
		DefVariables parametros = (DefVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-13)).value;
		int retornoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).left;
		int retornoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).right;
		TypeIF retorno = (TypeIF)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-10)).value;
		int sentencialeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int sentenciaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Sentencia sentencia = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ListaSentencias sentencias = (ListaSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
	String nombre = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	ScopeIF ambitoPadre = scopeManager.getParentScope();
	TypeTableIF tiposTablaPadre = ambitoPadre.getTypeTable();

	TypeFunction tipo = new TypeFunction(ambitoPadre, nombre, parametros.getVariables(), retorno);
	tiposTablaPadre.addType(tipo);
	System.out.println("Tipo añadido: " + tipo);
	
	// Comprobar que al menos se tiene un DEVOLVER en el cuerpo de la función
	Funcion funcion = new Funcion(sentencias.getSentencias(), sentencia);
	int numeroDevolver = funcion.comprobarDevolver(funcion.getSentencias());
	System.out.println("Numero sentencia devolver: " + numeroDevolver);
	
	if(numeroDevolver == 0) {
		semanticErrorManager.semanticFatalError("Funcion " + nombre + " no tiene sentencia DEVOLVER");
	}

	syntaxErrorManager.syntaxInfo("Ambito funcion " + nombre + " cerrado");
	scopeManager.closeScope();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcion",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-17)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // NT$2 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	// Al detectar el id de la función se tiene que abrir el ámbito
	String nombre = id.getLexema().toUpperCase();
	scopeManager.openScope(nombre);
	
	// Añadir tipos primitivos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeEntero entero = new TypeEntero(ambito);
	TypeLogico logico = new TypeLogico(ambito);
	TypeTableIF tiposTabla = ambito.getTypeTable();
	tiposTabla.addType(entero);
	tiposTabla.addType(logico);

	syntaxErrorManager.syntaxInfo("Ambito funcion " + nombre + " abierto");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // procedimiento ::= COMIENZOPROCEDIMIENTO IDEN NT$1 PIZQUIERDO defvariables PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias FINBLOQUESENTENCIAS DSENTENCIAS 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-13)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-14)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-14)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-14)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)).right;
		DefVariables parametros = (DefVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-11)).value;
		
	String nombre = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	ScopeIF ambitoPadre = scopeManager.getParentScope();
	TypeTableIF tiposTablaPadre = ambitoPadre.getTypeTable();
	
	TypeProcedure tipo = new TypeProcedure(ambitoPadre, nombre, parametros.getVariables());
	tiposTablaPadre.addType(tipo);
	
	syntaxErrorManager.syntaxInfo("Ambito procedimiento " + nombre + " cerrado");
	scopeManager.closeScope();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedimiento",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-15)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // NT$1 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	// Al detectar el id del procedimiento se tiene que abrir el ámbito
	String nombre = id.getLexema().toUpperCase();
	scopeManager.openScope(nombre);
	
	// Añadir tipos primitivos
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeEntero entero = new TypeEntero(ambito);
	TypeLogico logico = new TypeLogico(ambito);
	TypeTableIF tiposTabla = ambito.getTypeTable();
	tiposTabla.addType(entero);
	tiposTabla.addType(logico);
	
	syntaxErrorManager.syntaxInfo("Ambito procedimiento " + nombre + " abierto");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",49, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // tiporetornofuncion ::= tipovector 
            {
              TypeIF RESULT =null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		TypeIF tipo = (TypeIF)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	RESULT = tipo;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tiporetornofuncion",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // tiporetornofuncion ::= IDEN 
            {
              TypeIF RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	// No se permite devolver un vector
	semanticErrorManager.semanticFatalError("La funcion no puede devolver un tipo que no sea primitivo");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tiporetornofuncion",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // puntoycomaopcional ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("puntoycomaopcional",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // puntoycomaopcional ::= DSENTENCIAS 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("puntoycomaopcional",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // seccionvariables ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionvariables",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // seccionvariables ::= DECLVARIABLES defvariables 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionvariables",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // listavariables ::= epsilon 
            {
              ListaVariables RESULT =null;
		
	ListaVariables variables = new ListaVariables();
	RESULT = variables;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listavariables",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // listavariables ::= selectorvalororeferencia 
            {
              ListaVariables RESULT =null;
		int selectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int selectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SelectorValorOReferencia selector = (SelectorValorOReferencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ListaVariables variables = new ListaVariables();
	variables.addSelector(selector);
	RESULT = variables;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listavariables",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // listavariables ::= selectorvalororeferencia DIDENTIFICADORES listavariables 
            {
              ListaVariables RESULT =null;
		int selectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int selectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		SelectorValorOReferencia selector = (SelectorValorOReferencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int variablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int variablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaVariables variables = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	variables.addSelector(selector);
	RESULT = variables;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("listavariables",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // defvariables ::= epsilon 
            {
              DefVariables RESULT =null;
		
	DefVariables defV = new DefVariables();
	RESULT = defV;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defvariables",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // defvariables ::= listavariables DELIMFUNC tipovariable puntoycomaopcional defvariables 
            {
              DefVariables RESULT =null;
		int variablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int variablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		ListaVariables variables = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		TypeIF tipo = (TypeIF)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	ArrayList<SelectorValorOReferencia> identificadores = variables.getVariables();
	ArrayList<SymbolVariable> parametros = new ArrayList<SymbolVariable>();

	for(SelectorValorOReferencia selector : identificadores) {
		
		String nombre;
		if(selector.isPasoReferencia()) {
			nombre = selector.getIdentificador();
		} else {
			nombre = selector.getExpresion().getIdentificador();
		}

		// Comprobación unicidad
		if(simbolosTabla.containsSymbol(nombre)) {
			semanticErrorManager.semanticFatalError("Error semantico: identificador " + nombre + " duplicado");
		}
		SymbolVariable simbolo = new SymbolVariable(ambito, nombre, tipo, selector.isPasoReferencia());
		simbolosTabla.addSymbol(simbolo);
		parametros.add(simbolo);
	}

	DefVariables defV = new DefVariables(parametros);
	RESULT = defV;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defvariables",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // selectorvalororeferencia ::= expresion 
            {
              SelectorValorOReferencia RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	SelectorValorOReferencia selector = new SelectorValorOReferencia(exp);
	RESULT = selector;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorvalororeferencia",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // selectorvalororeferencia ::= PARAMETROVALOR IDEN 
            {
              SelectorValorOReferencia RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String nombre = id.getLexema().toUpperCase();
	SelectorValorOReferencia selector = new SelectorValorOReferencia(nombre);
	RESULT = selector;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selectorvalororeferencia",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // tipovariable ::= IDEN 
            {
              TypeIF RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String nombreTipo = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();

	if(tiposTabla.containsType(nombreTipo)) {
		TypeIF tipo = tiposTabla.getType(nombreTipo);
		RESULT = tipo;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: el tipo " + nombreTipo + " no esta declarado");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovariable",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // tipovariable ::= ENTERO 
            {
              TypeIF RESULT =null;
		
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	RESULT = tipo;
	

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovariable",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // tipovariable ::= BOOLEANO 
            {
              TypeIF RESULT =null;
		
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	RESULT = tipo;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovariable",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // secciontipos ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("secciontipos",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // secciontipos ::= COMIENZODECLTIPOS deftipos 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("secciontipos",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // valorango ::= miembrovector 
            {
              ValorRango RESULT =null;
		int miembroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int miembroright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		MiembroVector miembro = (MiembroVector)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	ValorRango vRango = new ValorRango(miembro);
	RESULT = vRango;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorango",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // valorango ::= IDEN 
            {
              ValorRango RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	String nombre = id.getLexema().toUpperCase();
	// Se busca el símbolo en la Tabla de Símbolos
	ScopeIF ambito = scopeManager.getCurrentScope();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
		
	if(simbolosTabla.containsSymbol(nombre)) {
		SymbolIF s = simbolosTabla.getSymbol(nombre);
		ValorRango vRango = new ValorRango(s);

		// CÓDIGO INTERMEDIO
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
		TemporalFactory tF = new TemporalFactory(ambito);
		TemporalIF temp = tF.create();

		if(s instanceof SymbolVariable) {
			//cb.addQuadruple("MVA", temp, new Variable((SymbolVariable)simbolo));
			//cb.addQuadruple("MVP", temp, new Variable((SymbolVariable)simbolo));
		} else if(s instanceof SymbolConstantEntero) {
			//cb.addQuadruple("MV", temp, 1);
		}

		vRango.setIntermediateCode(cb.create());
		vRango.setTemporal(temp);

		RESULT = vRango;
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: identificador " + nombre + " no esta declarado");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorango",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // valorango ::= NUM 
            {
              ValorRango RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	int val = Integer.parseInt(n.getLexema());
	ValorRango vRango = new ValorRango(val);

	// CÓDIGO INTERMEDIO
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);
	TemporalFactory tF = new TemporalFactory(ambito);
	TemporalIF temp = tF.create();
	cb.addQuadruple("MV", temp, new Value(val));
	vRango.setIntermediateCode(cb.create());
	vRango.setTemporal(temp);

	RESULT = vRango;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorango",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // tipovector ::= ENTERO 
            {
              TypeIF RESULT =null;
		
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("ENTERO");
	RESULT = tipo;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovector",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // tipovector ::= BOOLEANO 
            {
              TypeIF RESULT =null;
		
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	TypeIF tipo = tiposTabla.getType("LOGICO");
	RESULT = tipo;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipovector",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // deftipos ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("deftipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // deftipos ::= IDEN ASIGNACION DECLVECTOR CIZQUIERDO valorango RANGO valorango CDERECHO ASIGNACIONVECTOR tipovector DSENTENCIAS deftipos 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-11)).value;
		int valorn1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int valorn1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		ValorRango valorn1 = (ValorRango)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int valorn2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int valorn2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		ValorRango valorn2 = (ValorRango)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		TypeIF tipo = (TypeIF)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
	String nombre = id.getLexema().toUpperCase();
	ScopeIF ambito = scopeManager.getCurrentScope();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	
	// Comprobación unicidad
	if(tiposTabla.containsType(nombre)) {
		semanticErrorManager.semanticFatalError("Error semantico: identificador del tipo " + nombre + " duplicado");
	}

	// Se recupera valor de rango
	int rango1 = valorn1.getRangoVector();
	int rango2 = valorn2.getRangoVector();

	if(rango2 >= rango1) {
		TypeArray tipoArray = new TypeArray(ambito, nombre, rango1, rango2, tipo);
		tiposTabla.addType(tipoArray);
	} else {
		semanticErrorManager.semanticFatalError("Error semantico: el rango 2 del vector debe ser mayor o igual que el rango 1");
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("deftipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-11)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // seccionconstantes ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionconstantes",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // seccionconstantes ::= BCONSTANTES defconstantes 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("seccionconstantes",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // valorconstante ::= NUM 
            {
              ValorConstante RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new ValorConstante(Integer.parseInt(n.getLexema())); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorconstante",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // valorconstante ::= CIERTO 
            {
              ValorConstante RESULT =null;
		 RESULT = new ValorConstante(true); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorconstante",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // valorconstante ::= FALSO 
            {
              ValorConstante RESULT =null;
		 RESULT = new ValorConstante(false); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorconstante",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // defconstantes ::= epsilon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defconstantes",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // defconstantes ::= IDEN ASIGNACION valorconstante DSENTENCIAS defconstantes 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ValorConstante valor = (ValorConstante)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
	ScopeIF ambito = scopeManager.getCurrentScope();
	String nombre = id.getLexema().toUpperCase();
	TypeTableIF tiposTabla = ambito.getTypeTable();
	SymbolTableIF simbolosTabla = ambito.getSymbolTable();
	
	// Comprobación unicidad
	if(simbolosTabla.containsSymbol(nombre)) {
		semanticErrorManager.semanticFatalError("Error semantico: identificador "+ nombre +" duplicado");
	}
	
	if(valor.isEsValorEntero()) {
		// Constante entera
		TypeIF tipo = tiposTabla.getType("ENTERO");
		int valorEntero = valor.getValorEntero();
		SymbolConstantEntero simboloConstante = new SymbolConstantEntero(ambito, nombre, tipo, valorEntero);
		simbolosTabla.addSymbol(simboloConstante);
	} else {
		// Constante lógica
		TypeIF tipo = tiposTabla.getType("LOGICO");
		boolean valorLogico = valor.getValorLogico();
		SymbolConstantLogico simboloConstante = new SymbolConstantLogico(ambito, nombre, tipo, valorLogico);
		simbolosTabla.addSymbol(simboloConstante);
	}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("defconstantes",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // epsilon ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("epsilon",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // axiom ::= defprincipal 
            {
              Axiom RESULT =null;
		int defPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int defPright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DefPrincipal defP = (DefPrincipal)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
	AxiomPrincipal axiom = new AxiomPrincipal();
	ScopeIF ambito = scopeManager.getCurrentScope();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(ambito);

	// Se asignan direcciones de memoria
	MemoriaPrograma memoria = new MemoriaPrograma();
	memoria.asignarMemoria();

	cb.addQuadruple("INICIO", new Value(memoria.direccionInicio));
	cb.addQuadruples(defP.getIntermediateCode());
	cb.addQuadruple("HALT");

	axiom.setIntermediateCode(cb.create());

	RESULT = axiom;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
  	// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  	List<QuadrupleIF> intermediateCode = ax.getIntermediateCode ();
  	
	HashMap<String, String> textos = Textos.getTextos();
	syntaxErrorManager.syntaxInfo("TEXTOS: ");
	syntaxErrorManager.syntaxInfo("*****************");
	for(Entry<String, String> e : textos.entrySet()) {
		syntaxErrorManager.syntaxInfo(e.getKey() + ": " + e.getValue());
	}

	syntaxErrorManager.syntaxInfo("CODIGO INTERMEDIO");
	syntaxErrorManager.syntaxInfo("*****************");
	for(QuadrupleIF q : intermediateCode) {
		syntaxErrorManager.syntaxInfo(q.toString());
	}

	finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
	finalCodeFactory.create(intermediateCode);

  	// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  	// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  	// aún no se tendrá implementada la generación de código intermedio ni final.
  	// Para la entrega final deberán descomentarse y usarse.
  		
  	syntaxErrorManager.syntaxInfo ("Parsing process ended.");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 
	syntaxErrorManager.syntaxInfo ("Starting parsing..."); 

              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",48, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

